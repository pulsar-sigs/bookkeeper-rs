// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `BookkeeperProtocol.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct BKPacketHeader {
    // message fields
    version: ::std::option::Option<ProtocolVersion>,
    operation: ::std::option::Option<OperationType>,
    txnId: ::std::option::Option<u64>,
    priority: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BKPacketHeader {
    fn default() -> &'a BKPacketHeader {
        <BKPacketHeader as ::protobuf::Message>::default_instance()
    }
}

impl BKPacketHeader {
    pub fn new() -> BKPacketHeader {
        ::std::default::Default::default()
    }

    // required .bk.proto.ProtocolVersion version = 1;


    pub fn get_version(&self) -> ProtocolVersion {
        self.version.unwrap_or(ProtocolVersion::VERSION_ONE)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ProtocolVersion) {
        self.version = ::std::option::Option::Some(v);
    }

    // required .bk.proto.OperationType operation = 2;


    pub fn get_operation(&self) -> OperationType {
        self.operation.unwrap_or(OperationType::READ_ENTRY)
    }
    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: OperationType) {
        self.operation = ::std::option::Option::Some(v);
    }

    // required uint64 txnId = 3;


    pub fn get_txnId(&self) -> u64 {
        self.txnId.unwrap_or(0)
    }
    pub fn clear_txnId(&mut self) {
        self.txnId = ::std::option::Option::None;
    }

    pub fn has_txnId(&self) -> bool {
        self.txnId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnId(&mut self, v: u64) {
        self.txnId = ::std::option::Option::Some(v);
    }

    // optional uint32 priority = 4;


    pub fn get_priority(&self) -> u32 {
        self.priority.unwrap_or(0u32)
    }
    pub fn clear_priority(&mut self) {
        self.priority = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: u32) {
        self.priority = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BKPacketHeader {
    fn is_initialized(&self) -> bool {
        if self.version.is_none() {
            return false;
        }
        if self.operation.is_none() {
            return false;
        }
        if self.txnId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.version, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.operation, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnId = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.priority = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.txnId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.priority {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.operation {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.txnId {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.priority {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BKPacketHeader {
        BKPacketHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ProtocolVersion>>(
                "version",
                |m: &BKPacketHeader| { &m.version },
                |m: &mut BKPacketHeader| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperationType>>(
                "operation",
                |m: &BKPacketHeader| { &m.operation },
                |m: &mut BKPacketHeader| { &mut m.operation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "txnId",
                |m: &BKPacketHeader| { &m.txnId },
                |m: &mut BKPacketHeader| { &mut m.txnId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "priority",
                |m: &BKPacketHeader| { &m.priority },
                |m: &mut BKPacketHeader| { &mut m.priority },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BKPacketHeader>(
                "BKPacketHeader",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BKPacketHeader {
        static instance: ::protobuf::rt::LazyV2<BKPacketHeader> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BKPacketHeader::new)
    }
}

impl ::protobuf::Clear for BKPacketHeader {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.txnId = ::std::option::Option::None;
        self.priority = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BKPacketHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BKPacketHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContextPair {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContextPair {
    fn default() -> &'a ContextPair {
        <ContextPair as ::protobuf::Message>::default_instance()
    }
}

impl ContextPair {
    pub fn new() -> ContextPair {
        ::std::default::Default::default()
    }

    // required string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ContextPair {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContextPair {
        ContextPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &ContextPair| { &m.key },
                |m: &mut ContextPair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &ContextPair| { &m.value },
                |m: &mut ContextPair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContextPair>(
                "ContextPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContextPair {
        static instance: ::protobuf::rt::LazyV2<ContextPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContextPair::new)
    }
}

impl ::protobuf::Clear for ContextPair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContextPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContextPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request {
    // message fields
    pub header: ::protobuf::SingularPtrField<BKPacketHeader>,
    pub readRequest: ::protobuf::SingularPtrField<ReadRequest>,
    pub addRequest: ::protobuf::SingularPtrField<AddRequest>,
    pub authRequest: ::protobuf::SingularPtrField<AuthMessage>,
    pub writeLacRequest: ::protobuf::SingularPtrField<WriteLacRequest>,
    pub readLacRequest: ::protobuf::SingularPtrField<ReadLacRequest>,
    pub getBookieInfoRequest: ::protobuf::SingularPtrField<GetBookieInfoRequest>,
    pub startTLSRequest: ::protobuf::SingularPtrField<StartTLSRequest>,
    pub forceLedgerRequest: ::protobuf::SingularPtrField<ForceLedgerRequest>,
    pub getListOfEntriesOfLedgerRequest: ::protobuf::SingularPtrField<GetListOfEntriesOfLedgerRequest>,
    pub requestContext: ::protobuf::RepeatedField<ContextPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request {
    fn default() -> &'a Request {
        <Request as ::protobuf::Message>::default_instance()
    }
}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    // required .bk.proto.BKPacketHeader header = 1;


    pub fn get_header(&self) -> &BKPacketHeader {
        self.header.as_ref().unwrap_or_else(|| <BKPacketHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: BKPacketHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut BKPacketHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> BKPacketHeader {
        self.header.take().unwrap_or_else(|| BKPacketHeader::new())
    }

    // optional .bk.proto.ReadRequest readRequest = 100;


    pub fn get_readRequest(&self) -> &ReadRequest {
        self.readRequest.as_ref().unwrap_or_else(|| <ReadRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readRequest(&mut self) {
        self.readRequest.clear();
    }

    pub fn has_readRequest(&self) -> bool {
        self.readRequest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readRequest(&mut self, v: ReadRequest) {
        self.readRequest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readRequest(&mut self) -> &mut ReadRequest {
        if self.readRequest.is_none() {
            self.readRequest.set_default();
        }
        self.readRequest.as_mut().unwrap()
    }

    // Take field
    pub fn take_readRequest(&mut self) -> ReadRequest {
        self.readRequest.take().unwrap_or_else(|| ReadRequest::new())
    }

    // optional .bk.proto.AddRequest addRequest = 101;


    pub fn get_addRequest(&self) -> &AddRequest {
        self.addRequest.as_ref().unwrap_or_else(|| <AddRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addRequest(&mut self) {
        self.addRequest.clear();
    }

    pub fn has_addRequest(&self) -> bool {
        self.addRequest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addRequest(&mut self, v: AddRequest) {
        self.addRequest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addRequest(&mut self) -> &mut AddRequest {
        if self.addRequest.is_none() {
            self.addRequest.set_default();
        }
        self.addRequest.as_mut().unwrap()
    }

    // Take field
    pub fn take_addRequest(&mut self) -> AddRequest {
        self.addRequest.take().unwrap_or_else(|| AddRequest::new())
    }

    // optional .bk.proto.AuthMessage authRequest = 102;


    pub fn get_authRequest(&self) -> &AuthMessage {
        self.authRequest.as_ref().unwrap_or_else(|| <AuthMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authRequest(&mut self) {
        self.authRequest.clear();
    }

    pub fn has_authRequest(&self) -> bool {
        self.authRequest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authRequest(&mut self, v: AuthMessage) {
        self.authRequest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authRequest(&mut self) -> &mut AuthMessage {
        if self.authRequest.is_none() {
            self.authRequest.set_default();
        }
        self.authRequest.as_mut().unwrap()
    }

    // Take field
    pub fn take_authRequest(&mut self) -> AuthMessage {
        self.authRequest.take().unwrap_or_else(|| AuthMessage::new())
    }

    // optional .bk.proto.WriteLacRequest writeLacRequest = 103;


    pub fn get_writeLacRequest(&self) -> &WriteLacRequest {
        self.writeLacRequest.as_ref().unwrap_or_else(|| <WriteLacRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_writeLacRequest(&mut self) {
        self.writeLacRequest.clear();
    }

    pub fn has_writeLacRequest(&self) -> bool {
        self.writeLacRequest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writeLacRequest(&mut self, v: WriteLacRequest) {
        self.writeLacRequest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_writeLacRequest(&mut self) -> &mut WriteLacRequest {
        if self.writeLacRequest.is_none() {
            self.writeLacRequest.set_default();
        }
        self.writeLacRequest.as_mut().unwrap()
    }

    // Take field
    pub fn take_writeLacRequest(&mut self) -> WriteLacRequest {
        self.writeLacRequest.take().unwrap_or_else(|| WriteLacRequest::new())
    }

    // optional .bk.proto.ReadLacRequest readLacRequest = 104;


    pub fn get_readLacRequest(&self) -> &ReadLacRequest {
        self.readLacRequest.as_ref().unwrap_or_else(|| <ReadLacRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readLacRequest(&mut self) {
        self.readLacRequest.clear();
    }

    pub fn has_readLacRequest(&self) -> bool {
        self.readLacRequest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readLacRequest(&mut self, v: ReadLacRequest) {
        self.readLacRequest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readLacRequest(&mut self) -> &mut ReadLacRequest {
        if self.readLacRequest.is_none() {
            self.readLacRequest.set_default();
        }
        self.readLacRequest.as_mut().unwrap()
    }

    // Take field
    pub fn take_readLacRequest(&mut self) -> ReadLacRequest {
        self.readLacRequest.take().unwrap_or_else(|| ReadLacRequest::new())
    }

    // optional .bk.proto.GetBookieInfoRequest getBookieInfoRequest = 105;


    pub fn get_getBookieInfoRequest(&self) -> &GetBookieInfoRequest {
        self.getBookieInfoRequest.as_ref().unwrap_or_else(|| <GetBookieInfoRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getBookieInfoRequest(&mut self) {
        self.getBookieInfoRequest.clear();
    }

    pub fn has_getBookieInfoRequest(&self) -> bool {
        self.getBookieInfoRequest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getBookieInfoRequest(&mut self, v: GetBookieInfoRequest) {
        self.getBookieInfoRequest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getBookieInfoRequest(&mut self) -> &mut GetBookieInfoRequest {
        if self.getBookieInfoRequest.is_none() {
            self.getBookieInfoRequest.set_default();
        }
        self.getBookieInfoRequest.as_mut().unwrap()
    }

    // Take field
    pub fn take_getBookieInfoRequest(&mut self) -> GetBookieInfoRequest {
        self.getBookieInfoRequest.take().unwrap_or_else(|| GetBookieInfoRequest::new())
    }

    // optional .bk.proto.StartTLSRequest startTLSRequest = 106;


    pub fn get_startTLSRequest(&self) -> &StartTLSRequest {
        self.startTLSRequest.as_ref().unwrap_or_else(|| <StartTLSRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_startTLSRequest(&mut self) {
        self.startTLSRequest.clear();
    }

    pub fn has_startTLSRequest(&self) -> bool {
        self.startTLSRequest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTLSRequest(&mut self, v: StartTLSRequest) {
        self.startTLSRequest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startTLSRequest(&mut self) -> &mut StartTLSRequest {
        if self.startTLSRequest.is_none() {
            self.startTLSRequest.set_default();
        }
        self.startTLSRequest.as_mut().unwrap()
    }

    // Take field
    pub fn take_startTLSRequest(&mut self) -> StartTLSRequest {
        self.startTLSRequest.take().unwrap_or_else(|| StartTLSRequest::new())
    }

    // optional .bk.proto.ForceLedgerRequest forceLedgerRequest = 107;


    pub fn get_forceLedgerRequest(&self) -> &ForceLedgerRequest {
        self.forceLedgerRequest.as_ref().unwrap_or_else(|| <ForceLedgerRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_forceLedgerRequest(&mut self) {
        self.forceLedgerRequest.clear();
    }

    pub fn has_forceLedgerRequest(&self) -> bool {
        self.forceLedgerRequest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forceLedgerRequest(&mut self, v: ForceLedgerRequest) {
        self.forceLedgerRequest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forceLedgerRequest(&mut self) -> &mut ForceLedgerRequest {
        if self.forceLedgerRequest.is_none() {
            self.forceLedgerRequest.set_default();
        }
        self.forceLedgerRequest.as_mut().unwrap()
    }

    // Take field
    pub fn take_forceLedgerRequest(&mut self) -> ForceLedgerRequest {
        self.forceLedgerRequest.take().unwrap_or_else(|| ForceLedgerRequest::new())
    }

    // optional .bk.proto.GetListOfEntriesOfLedgerRequest getListOfEntriesOfLedgerRequest = 108;


    pub fn get_getListOfEntriesOfLedgerRequest(&self) -> &GetListOfEntriesOfLedgerRequest {
        self.getListOfEntriesOfLedgerRequest.as_ref().unwrap_or_else(|| <GetListOfEntriesOfLedgerRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getListOfEntriesOfLedgerRequest(&mut self) {
        self.getListOfEntriesOfLedgerRequest.clear();
    }

    pub fn has_getListOfEntriesOfLedgerRequest(&self) -> bool {
        self.getListOfEntriesOfLedgerRequest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getListOfEntriesOfLedgerRequest(&mut self, v: GetListOfEntriesOfLedgerRequest) {
        self.getListOfEntriesOfLedgerRequest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getListOfEntriesOfLedgerRequest(&mut self) -> &mut GetListOfEntriesOfLedgerRequest {
        if self.getListOfEntriesOfLedgerRequest.is_none() {
            self.getListOfEntriesOfLedgerRequest.set_default();
        }
        self.getListOfEntriesOfLedgerRequest.as_mut().unwrap()
    }

    // Take field
    pub fn take_getListOfEntriesOfLedgerRequest(&mut self) -> GetListOfEntriesOfLedgerRequest {
        self.getListOfEntriesOfLedgerRequest.take().unwrap_or_else(|| GetListOfEntriesOfLedgerRequest::new())
    }

    // repeated .bk.proto.ContextPair requestContext = 200;


    pub fn get_requestContext(&self) -> &[ContextPair] {
        &self.requestContext
    }
    pub fn clear_requestContext(&mut self) {
        self.requestContext.clear();
    }

    // Param is passed by value, moved
    pub fn set_requestContext(&mut self, v: ::protobuf::RepeatedField<ContextPair>) {
        self.requestContext = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requestContext(&mut self) -> &mut ::protobuf::RepeatedField<ContextPair> {
        &mut self.requestContext
    }

    // Take field
    pub fn take_requestContext(&mut self) -> ::protobuf::RepeatedField<ContextPair> {
        ::std::mem::replace(&mut self.requestContext, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Request {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.addRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.writeLacRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readLacRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getBookieInfoRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.startTLSRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.forceLedgerRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getListOfEntriesOfLedgerRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.requestContext {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                100 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readRequest)?;
                },
                101 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addRequest)?;
                },
                102 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authRequest)?;
                },
                103 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.writeLacRequest)?;
                },
                104 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readLacRequest)?;
                },
                105 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getBookieInfoRequest)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startTLSRequest)?;
                },
                107 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.forceLedgerRequest)?;
                },
                108 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getListOfEntriesOfLedgerRequest)?;
                },
                200 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requestContext)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.addRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.writeLacRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readLacRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getBookieInfoRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.startTLSRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.forceLedgerRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getListOfEntriesOfLedgerRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.requestContext {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readRequest.as_ref() {
            os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.addRequest.as_ref() {
            os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authRequest.as_ref() {
            os.write_tag(102, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.writeLacRequest.as_ref() {
            os.write_tag(103, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readLacRequest.as_ref() {
            os.write_tag(104, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getBookieInfoRequest.as_ref() {
            os.write_tag(105, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.startTLSRequest.as_ref() {
            os.write_tag(106, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.forceLedgerRequest.as_ref() {
            os.write_tag(107, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getListOfEntriesOfLedgerRequest.as_ref() {
            os.write_tag(108, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.requestContext {
            os.write_tag(200, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request {
        Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BKPacketHeader>>(
                "header",
                |m: &Request| { &m.header },
                |m: &mut Request| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadRequest>>(
                "readRequest",
                |m: &Request| { &m.readRequest },
                |m: &mut Request| { &mut m.readRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddRequest>>(
                "addRequest",
                |m: &Request| { &m.addRequest },
                |m: &mut Request| { &mut m.addRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthMessage>>(
                "authRequest",
                |m: &Request| { &m.authRequest },
                |m: &mut Request| { &mut m.authRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WriteLacRequest>>(
                "writeLacRequest",
                |m: &Request| { &m.writeLacRequest },
                |m: &mut Request| { &mut m.writeLacRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadLacRequest>>(
                "readLacRequest",
                |m: &Request| { &m.readLacRequest },
                |m: &mut Request| { &mut m.readLacRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetBookieInfoRequest>>(
                "getBookieInfoRequest",
                |m: &Request| { &m.getBookieInfoRequest },
                |m: &mut Request| { &mut m.getBookieInfoRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StartTLSRequest>>(
                "startTLSRequest",
                |m: &Request| { &m.startTLSRequest },
                |m: &mut Request| { &mut m.startTLSRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForceLedgerRequest>>(
                "forceLedgerRequest",
                |m: &Request| { &m.forceLedgerRequest },
                |m: &mut Request| { &mut m.forceLedgerRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetListOfEntriesOfLedgerRequest>>(
                "getListOfEntriesOfLedgerRequest",
                |m: &Request| { &m.getListOfEntriesOfLedgerRequest },
                |m: &mut Request| { &mut m.getListOfEntriesOfLedgerRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContextPair>>(
                "requestContext",
                |m: &Request| { &m.requestContext },
                |m: &mut Request| { &mut m.requestContext },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request>(
                "Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request {
        static instance: ::protobuf::rt::LazyV2<Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request::new)
    }
}

impl ::protobuf::Clear for Request {
    fn clear(&mut self) {
        self.header.clear();
        self.readRequest.clear();
        self.addRequest.clear();
        self.authRequest.clear();
        self.writeLacRequest.clear();
        self.readLacRequest.clear();
        self.getBookieInfoRequest.clear();
        self.startTLSRequest.clear();
        self.forceLedgerRequest.clear();
        self.getListOfEntriesOfLedgerRequest.clear();
        self.requestContext.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadRequest {
    // message fields
    flag: ::std::option::Option<ReadRequest_Flag>,
    ledgerId: ::std::option::Option<i64>,
    entryId: ::std::option::Option<i64>,
    masterKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    previousLAC: ::std::option::Option<i64>,
    timeOut: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadRequest {
    fn default() -> &'a ReadRequest {
        <ReadRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReadRequest {
    pub fn new() -> ReadRequest {
        ::std::default::Default::default()
    }

    // optional .bk.proto.ReadRequest.Flag flag = 100;


    pub fn get_flag(&self) -> ReadRequest_Flag {
        self.flag.unwrap_or(ReadRequest_Flag::FENCE_LEDGER)
    }
    pub fn clear_flag(&mut self) {
        self.flag = ::std::option::Option::None;
    }

    pub fn has_flag(&self) -> bool {
        self.flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flag(&mut self, v: ReadRequest_Flag) {
        self.flag = ::std::option::Option::Some(v);
    }

    // required int64 ledgerId = 1;


    pub fn get_ledgerId(&self) -> i64 {
        self.ledgerId.unwrap_or(0)
    }
    pub fn clear_ledgerId(&mut self) {
        self.ledgerId = ::std::option::Option::None;
    }

    pub fn has_ledgerId(&self) -> bool {
        self.ledgerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerId(&mut self, v: i64) {
        self.ledgerId = ::std::option::Option::Some(v);
    }

    // required int64 entryId = 2;


    pub fn get_entryId(&self) -> i64 {
        self.entryId.unwrap_or(0)
    }
    pub fn clear_entryId(&mut self) {
        self.entryId = ::std::option::Option::None;
    }

    pub fn has_entryId(&self) -> bool {
        self.entryId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryId(&mut self, v: i64) {
        self.entryId = ::std::option::Option::Some(v);
    }

    // optional bytes masterKey = 3;


    pub fn get_masterKey(&self) -> &[u8] {
        match self.masterKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_masterKey(&mut self) {
        self.masterKey.clear();
    }

    pub fn has_masterKey(&self) -> bool {
        self.masterKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masterKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.masterKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masterKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.masterKey.is_none() {
            self.masterKey.set_default();
        }
        self.masterKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_masterKey(&mut self) -> ::std::vec::Vec<u8> {
        self.masterKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int64 previousLAC = 4;


    pub fn get_previousLAC(&self) -> i64 {
        self.previousLAC.unwrap_or(0)
    }
    pub fn clear_previousLAC(&mut self) {
        self.previousLAC = ::std::option::Option::None;
    }

    pub fn has_previousLAC(&self) -> bool {
        self.previousLAC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previousLAC(&mut self, v: i64) {
        self.previousLAC = ::std::option::Option::Some(v);
    }

    // optional int64 timeOut = 5;


    pub fn get_timeOut(&self) -> i64 {
        self.timeOut.unwrap_or(0)
    }
    pub fn clear_timeOut(&mut self) {
        self.timeOut = ::std::option::Option::None;
    }

    pub fn has_timeOut(&self) -> bool {
        self.timeOut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeOut(&mut self, v: i64) {
        self.timeOut = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ReadRequest {
    fn is_initialized(&self) -> bool {
        if self.ledgerId.is_none() {
            return false;
        }
        if self.entryId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                100 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.flag, 100, &mut self.unknown_fields)?
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ledgerId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.entryId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.masterKey)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.previousLAC = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timeOut = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.flag {
            my_size += ::protobuf::rt::enum_size(100, v);
        }
        if let Some(v) = self.ledgerId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entryId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.masterKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.previousLAC {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeOut {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.flag {
            os.write_enum(100, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.ledgerId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.entryId {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.masterKey.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.previousLAC {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.timeOut {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadRequest {
        ReadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReadRequest_Flag>>(
                "flag",
                |m: &ReadRequest| { &m.flag },
                |m: &mut ReadRequest| { &mut m.flag },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ledgerId",
                |m: &ReadRequest| { &m.ledgerId },
                |m: &mut ReadRequest| { &mut m.ledgerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "entryId",
                |m: &ReadRequest| { &m.entryId },
                |m: &mut ReadRequest| { &mut m.entryId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "masterKey",
                |m: &ReadRequest| { &m.masterKey },
                |m: &mut ReadRequest| { &mut m.masterKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "previousLAC",
                |m: &ReadRequest| { &m.previousLAC },
                |m: &mut ReadRequest| { &mut m.previousLAC },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timeOut",
                |m: &ReadRequest| { &m.timeOut },
                |m: &mut ReadRequest| { &mut m.timeOut },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadRequest>(
                "ReadRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadRequest {
        static instance: ::protobuf::rt::LazyV2<ReadRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadRequest::new)
    }
}

impl ::protobuf::Clear for ReadRequest {
    fn clear(&mut self) {
        self.flag = ::std::option::Option::None;
        self.ledgerId = ::std::option::Option::None;
        self.entryId = ::std::option::Option::None;
        self.masterKey.clear();
        self.previousLAC = ::std::option::Option::None;
        self.timeOut = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReadRequest_Flag {
    FENCE_LEDGER = 1,
    ENTRY_PIGGYBACK = 2,
}

impl ::protobuf::ProtobufEnum for ReadRequest_Flag {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReadRequest_Flag> {
        match value {
            1 => ::std::option::Option::Some(ReadRequest_Flag::FENCE_LEDGER),
            2 => ::std::option::Option::Some(ReadRequest_Flag::ENTRY_PIGGYBACK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReadRequest_Flag] = &[
            ReadRequest_Flag::FENCE_LEDGER,
            ReadRequest_Flag::ENTRY_PIGGYBACK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ReadRequest_Flag>("ReadRequest.Flag", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ReadRequest_Flag {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ReadRequest_Flag {
    fn default() -> Self {
        ReadRequest_Flag::FENCE_LEDGER
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadRequest_Flag {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddRequest {
    // message fields
    flag: ::std::option::Option<AddRequest_Flag>,
    ledgerId: ::std::option::Option<i64>,
    entryId: ::std::option::Option<i64>,
    masterKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    body: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    writeFlags: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddRequest {
    fn default() -> &'a AddRequest {
        <AddRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddRequest {
    pub fn new() -> AddRequest {
        ::std::default::Default::default()
    }

    // optional .bk.proto.AddRequest.Flag flag = 100;


    pub fn get_flag(&self) -> AddRequest_Flag {
        self.flag.unwrap_or(AddRequest_Flag::RECOVERY_ADD)
    }
    pub fn clear_flag(&mut self) {
        self.flag = ::std::option::Option::None;
    }

    pub fn has_flag(&self) -> bool {
        self.flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flag(&mut self, v: AddRequest_Flag) {
        self.flag = ::std::option::Option::Some(v);
    }

    // required int64 ledgerId = 1;


    pub fn get_ledgerId(&self) -> i64 {
        self.ledgerId.unwrap_or(0)
    }
    pub fn clear_ledgerId(&mut self) {
        self.ledgerId = ::std::option::Option::None;
    }

    pub fn has_ledgerId(&self) -> bool {
        self.ledgerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerId(&mut self, v: i64) {
        self.ledgerId = ::std::option::Option::Some(v);
    }

    // required int64 entryId = 2;


    pub fn get_entryId(&self) -> i64 {
        self.entryId.unwrap_or(0)
    }
    pub fn clear_entryId(&mut self) {
        self.entryId = ::std::option::Option::None;
    }

    pub fn has_entryId(&self) -> bool {
        self.entryId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryId(&mut self, v: i64) {
        self.entryId = ::std::option::Option::Some(v);
    }

    // required bytes masterKey = 3;


    pub fn get_masterKey(&self) -> &[u8] {
        match self.masterKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_masterKey(&mut self) {
        self.masterKey.clear();
    }

    pub fn has_masterKey(&self) -> bool {
        self.masterKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masterKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.masterKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masterKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.masterKey.is_none() {
            self.masterKey.set_default();
        }
        self.masterKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_masterKey(&mut self) -> ::std::vec::Vec<u8> {
        self.masterKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes body = 4;


    pub fn get_body(&self) -> &[u8] {
        match self.body.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        self.body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 writeFlags = 5;


    pub fn get_writeFlags(&self) -> i32 {
        self.writeFlags.unwrap_or(0)
    }
    pub fn clear_writeFlags(&mut self) {
        self.writeFlags = ::std::option::Option::None;
    }

    pub fn has_writeFlags(&self) -> bool {
        self.writeFlags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writeFlags(&mut self, v: i32) {
        self.writeFlags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AddRequest {
    fn is_initialized(&self) -> bool {
        if self.ledgerId.is_none() {
            return false;
        }
        if self.entryId.is_none() {
            return false;
        }
        if self.masterKey.is_none() {
            return false;
        }
        if self.body.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                100 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.flag, 100, &mut self.unknown_fields)?
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ledgerId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.entryId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.masterKey)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.body)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.writeFlags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.flag {
            my_size += ::protobuf::rt::enum_size(100, v);
        }
        if let Some(v) = self.ledgerId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entryId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.masterKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.writeFlags {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.flag {
            os.write_enum(100, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.ledgerId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.entryId {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.masterKey.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.writeFlags {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddRequest {
        AddRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AddRequest_Flag>>(
                "flag",
                |m: &AddRequest| { &m.flag },
                |m: &mut AddRequest| { &mut m.flag },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ledgerId",
                |m: &AddRequest| { &m.ledgerId },
                |m: &mut AddRequest| { &mut m.ledgerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "entryId",
                |m: &AddRequest| { &m.entryId },
                |m: &mut AddRequest| { &mut m.entryId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "masterKey",
                |m: &AddRequest| { &m.masterKey },
                |m: &mut AddRequest| { &mut m.masterKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "body",
                |m: &AddRequest| { &m.body },
                |m: &mut AddRequest| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "writeFlags",
                |m: &AddRequest| { &m.writeFlags },
                |m: &mut AddRequest| { &mut m.writeFlags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddRequest>(
                "AddRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddRequest {
        static instance: ::protobuf::rt::LazyV2<AddRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddRequest::new)
    }
}

impl ::protobuf::Clear for AddRequest {
    fn clear(&mut self) {
        self.flag = ::std::option::Option::None;
        self.ledgerId = ::std::option::Option::None;
        self.entryId = ::std::option::Option::None;
        self.masterKey.clear();
        self.body.clear();
        self.writeFlags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AddRequest_Flag {
    RECOVERY_ADD = 1,
}

impl ::protobuf::ProtobufEnum for AddRequest_Flag {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AddRequest_Flag> {
        match value {
            1 => ::std::option::Option::Some(AddRequest_Flag::RECOVERY_ADD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AddRequest_Flag] = &[
            AddRequest_Flag::RECOVERY_ADD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AddRequest_Flag>("AddRequest.Flag", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AddRequest_Flag {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for AddRequest_Flag {
    fn default() -> Self {
        AddRequest_Flag::RECOVERY_ADD
    }
}

impl ::protobuf::reflect::ProtobufValue for AddRequest_Flag {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartTLSRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartTLSRequest {
    fn default() -> &'a StartTLSRequest {
        <StartTLSRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartTLSRequest {
    pub fn new() -> StartTLSRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartTLSRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartTLSRequest {
        StartTLSRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartTLSRequest>(
                "StartTLSRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartTLSRequest {
        static instance: ::protobuf::rt::LazyV2<StartTLSRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartTLSRequest::new)
    }
}

impl ::protobuf::Clear for StartTLSRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartTLSRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartTLSRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteLacRequest {
    // message fields
    ledgerId: ::std::option::Option<i64>,
    lac: ::std::option::Option<i64>,
    masterKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    body: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteLacRequest {
    fn default() -> &'a WriteLacRequest {
        <WriteLacRequest as ::protobuf::Message>::default_instance()
    }
}

impl WriteLacRequest {
    pub fn new() -> WriteLacRequest {
        ::std::default::Default::default()
    }

    // required int64 ledgerId = 1;


    pub fn get_ledgerId(&self) -> i64 {
        self.ledgerId.unwrap_or(0)
    }
    pub fn clear_ledgerId(&mut self) {
        self.ledgerId = ::std::option::Option::None;
    }

    pub fn has_ledgerId(&self) -> bool {
        self.ledgerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerId(&mut self, v: i64) {
        self.ledgerId = ::std::option::Option::Some(v);
    }

    // required int64 lac = 2;


    pub fn get_lac(&self) -> i64 {
        self.lac.unwrap_or(0)
    }
    pub fn clear_lac(&mut self) {
        self.lac = ::std::option::Option::None;
    }

    pub fn has_lac(&self) -> bool {
        self.lac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lac(&mut self, v: i64) {
        self.lac = ::std::option::Option::Some(v);
    }

    // required bytes masterKey = 3;


    pub fn get_masterKey(&self) -> &[u8] {
        match self.masterKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_masterKey(&mut self) {
        self.masterKey.clear();
    }

    pub fn has_masterKey(&self) -> bool {
        self.masterKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masterKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.masterKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masterKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.masterKey.is_none() {
            self.masterKey.set_default();
        }
        self.masterKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_masterKey(&mut self) -> ::std::vec::Vec<u8> {
        self.masterKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes body = 4;


    pub fn get_body(&self) -> &[u8] {
        match self.body.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        self.body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for WriteLacRequest {
    fn is_initialized(&self) -> bool {
        if self.ledgerId.is_none() {
            return false;
        }
        if self.lac.is_none() {
            return false;
        }
        if self.masterKey.is_none() {
            return false;
        }
        if self.body.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ledgerId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lac = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.masterKey)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ledgerId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lac {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.masterKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ledgerId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.lac {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.masterKey.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteLacRequest {
        WriteLacRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ledgerId",
                |m: &WriteLacRequest| { &m.ledgerId },
                |m: &mut WriteLacRequest| { &mut m.ledgerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lac",
                |m: &WriteLacRequest| { &m.lac },
                |m: &mut WriteLacRequest| { &mut m.lac },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "masterKey",
                |m: &WriteLacRequest| { &m.masterKey },
                |m: &mut WriteLacRequest| { &mut m.masterKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "body",
                |m: &WriteLacRequest| { &m.body },
                |m: &mut WriteLacRequest| { &mut m.body },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WriteLacRequest>(
                "WriteLacRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WriteLacRequest {
        static instance: ::protobuf::rt::LazyV2<WriteLacRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WriteLacRequest::new)
    }
}

impl ::protobuf::Clear for WriteLacRequest {
    fn clear(&mut self) {
        self.ledgerId = ::std::option::Option::None;
        self.lac = ::std::option::Option::None;
        self.masterKey.clear();
        self.body.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteLacRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteLacRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ForceLedgerRequest {
    // message fields
    ledgerId: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForceLedgerRequest {
    fn default() -> &'a ForceLedgerRequest {
        <ForceLedgerRequest as ::protobuf::Message>::default_instance()
    }
}

impl ForceLedgerRequest {
    pub fn new() -> ForceLedgerRequest {
        ::std::default::Default::default()
    }

    // required int64 ledgerId = 1;


    pub fn get_ledgerId(&self) -> i64 {
        self.ledgerId.unwrap_or(0)
    }
    pub fn clear_ledgerId(&mut self) {
        self.ledgerId = ::std::option::Option::None;
    }

    pub fn has_ledgerId(&self) -> bool {
        self.ledgerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerId(&mut self, v: i64) {
        self.ledgerId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ForceLedgerRequest {
    fn is_initialized(&self) -> bool {
        if self.ledgerId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ledgerId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ledgerId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ledgerId {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForceLedgerRequest {
        ForceLedgerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ledgerId",
                |m: &ForceLedgerRequest| { &m.ledgerId },
                |m: &mut ForceLedgerRequest| { &mut m.ledgerId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ForceLedgerRequest>(
                "ForceLedgerRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ForceLedgerRequest {
        static instance: ::protobuf::rt::LazyV2<ForceLedgerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ForceLedgerRequest::new)
    }
}

impl ::protobuf::Clear for ForceLedgerRequest {
    fn clear(&mut self) {
        self.ledgerId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForceLedgerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForceLedgerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadLacRequest {
    // message fields
    ledgerId: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadLacRequest {
    fn default() -> &'a ReadLacRequest {
        <ReadLacRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReadLacRequest {
    pub fn new() -> ReadLacRequest {
        ::std::default::Default::default()
    }

    // required int64 ledgerId = 1;


    pub fn get_ledgerId(&self) -> i64 {
        self.ledgerId.unwrap_or(0)
    }
    pub fn clear_ledgerId(&mut self) {
        self.ledgerId = ::std::option::Option::None;
    }

    pub fn has_ledgerId(&self) -> bool {
        self.ledgerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerId(&mut self, v: i64) {
        self.ledgerId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ReadLacRequest {
    fn is_initialized(&self) -> bool {
        if self.ledgerId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ledgerId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ledgerId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ledgerId {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadLacRequest {
        ReadLacRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ledgerId",
                |m: &ReadLacRequest| { &m.ledgerId },
                |m: &mut ReadLacRequest| { &mut m.ledgerId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadLacRequest>(
                "ReadLacRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadLacRequest {
        static instance: ::protobuf::rt::LazyV2<ReadLacRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadLacRequest::new)
    }
}

impl ::protobuf::Clear for ReadLacRequest {
    fn clear(&mut self) {
        self.ledgerId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadLacRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadLacRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBookieInfoRequest {
    // message fields
    requested: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBookieInfoRequest {
    fn default() -> &'a GetBookieInfoRequest {
        <GetBookieInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBookieInfoRequest {
    pub fn new() -> GetBookieInfoRequest {
        ::std::default::Default::default()
    }

    // optional int64 requested = 1;


    pub fn get_requested(&self) -> i64 {
        self.requested.unwrap_or(0)
    }
    pub fn clear_requested(&mut self) {
        self.requested = ::std::option::Option::None;
    }

    pub fn has_requested(&self) -> bool {
        self.requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requested(&mut self, v: i64) {
        self.requested = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetBookieInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.requested = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.requested {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.requested {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBookieInfoRequest {
        GetBookieInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "requested",
                |m: &GetBookieInfoRequest| { &m.requested },
                |m: &mut GetBookieInfoRequest| { &mut m.requested },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBookieInfoRequest>(
                "GetBookieInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBookieInfoRequest {
        static instance: ::protobuf::rt::LazyV2<GetBookieInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBookieInfoRequest::new)
    }
}

impl ::protobuf::Clear for GetBookieInfoRequest {
    fn clear(&mut self) {
        self.requested = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBookieInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBookieInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GetBookieInfoRequest_Flags {
    TOTAL_DISK_CAPACITY = 1,
    FREE_DISK_SPACE = 2,
}

impl ::protobuf::ProtobufEnum for GetBookieInfoRequest_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GetBookieInfoRequest_Flags> {
        match value {
            1 => ::std::option::Option::Some(GetBookieInfoRequest_Flags::TOTAL_DISK_CAPACITY),
            2 => ::std::option::Option::Some(GetBookieInfoRequest_Flags::FREE_DISK_SPACE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GetBookieInfoRequest_Flags] = &[
            GetBookieInfoRequest_Flags::TOTAL_DISK_CAPACITY,
            GetBookieInfoRequest_Flags::FREE_DISK_SPACE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GetBookieInfoRequest_Flags>("GetBookieInfoRequest.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GetBookieInfoRequest_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for GetBookieInfoRequest_Flags {
    fn default() -> Self {
        GetBookieInfoRequest_Flags::TOTAL_DISK_CAPACITY
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBookieInfoRequest_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetListOfEntriesOfLedgerRequest {
    // message fields
    ledgerId: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetListOfEntriesOfLedgerRequest {
    fn default() -> &'a GetListOfEntriesOfLedgerRequest {
        <GetListOfEntriesOfLedgerRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetListOfEntriesOfLedgerRequest {
    pub fn new() -> GetListOfEntriesOfLedgerRequest {
        ::std::default::Default::default()
    }

    // required int64 ledgerId = 1;


    pub fn get_ledgerId(&self) -> i64 {
        self.ledgerId.unwrap_or(0)
    }
    pub fn clear_ledgerId(&mut self) {
        self.ledgerId = ::std::option::Option::None;
    }

    pub fn has_ledgerId(&self) -> bool {
        self.ledgerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerId(&mut self, v: i64) {
        self.ledgerId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetListOfEntriesOfLedgerRequest {
    fn is_initialized(&self) -> bool {
        if self.ledgerId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ledgerId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ledgerId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ledgerId {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetListOfEntriesOfLedgerRequest {
        GetListOfEntriesOfLedgerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ledgerId",
                |m: &GetListOfEntriesOfLedgerRequest| { &m.ledgerId },
                |m: &mut GetListOfEntriesOfLedgerRequest| { &mut m.ledgerId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetListOfEntriesOfLedgerRequest>(
                "GetListOfEntriesOfLedgerRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetListOfEntriesOfLedgerRequest {
        static instance: ::protobuf::rt::LazyV2<GetListOfEntriesOfLedgerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetListOfEntriesOfLedgerRequest::new)
    }
}

impl ::protobuf::Clear for GetListOfEntriesOfLedgerRequest {
    fn clear(&mut self) {
        self.ledgerId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetListOfEntriesOfLedgerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetListOfEntriesOfLedgerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response {
    // message fields
    pub header: ::protobuf::SingularPtrField<BKPacketHeader>,
    status: ::std::option::Option<StatusCode>,
    pub readResponse: ::protobuf::SingularPtrField<ReadResponse>,
    pub addResponse: ::protobuf::SingularPtrField<AddResponse>,
    pub authResponse: ::protobuf::SingularPtrField<AuthMessage>,
    pub writeLacResponse: ::protobuf::SingularPtrField<WriteLacResponse>,
    pub readLacResponse: ::protobuf::SingularPtrField<ReadLacResponse>,
    pub getBookieInfoResponse: ::protobuf::SingularPtrField<GetBookieInfoResponse>,
    pub startTLSResponse: ::protobuf::SingularPtrField<StartTLSResponse>,
    pub forceLedgerResponse: ::protobuf::SingularPtrField<ForceLedgerResponse>,
    pub getListOfEntriesOfLedgerResponse: ::protobuf::SingularPtrField<GetListOfEntriesOfLedgerResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // required .bk.proto.BKPacketHeader header = 1;


    pub fn get_header(&self) -> &BKPacketHeader {
        self.header.as_ref().unwrap_or_else(|| <BKPacketHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: BKPacketHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut BKPacketHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> BKPacketHeader {
        self.header.take().unwrap_or_else(|| BKPacketHeader::new())
    }

    // required .bk.proto.StatusCode status = 2;


    pub fn get_status(&self) -> StatusCode {
        self.status.unwrap_or(StatusCode::EOK)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: StatusCode) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional .bk.proto.ReadResponse readResponse = 100;


    pub fn get_readResponse(&self) -> &ReadResponse {
        self.readResponse.as_ref().unwrap_or_else(|| <ReadResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readResponse(&mut self) {
        self.readResponse.clear();
    }

    pub fn has_readResponse(&self) -> bool {
        self.readResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readResponse(&mut self, v: ReadResponse) {
        self.readResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readResponse(&mut self) -> &mut ReadResponse {
        if self.readResponse.is_none() {
            self.readResponse.set_default();
        }
        self.readResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_readResponse(&mut self) -> ReadResponse {
        self.readResponse.take().unwrap_or_else(|| ReadResponse::new())
    }

    // optional .bk.proto.AddResponse addResponse = 101;


    pub fn get_addResponse(&self) -> &AddResponse {
        self.addResponse.as_ref().unwrap_or_else(|| <AddResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addResponse(&mut self) {
        self.addResponse.clear();
    }

    pub fn has_addResponse(&self) -> bool {
        self.addResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addResponse(&mut self, v: AddResponse) {
        self.addResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addResponse(&mut self) -> &mut AddResponse {
        if self.addResponse.is_none() {
            self.addResponse.set_default();
        }
        self.addResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_addResponse(&mut self) -> AddResponse {
        self.addResponse.take().unwrap_or_else(|| AddResponse::new())
    }

    // optional .bk.proto.AuthMessage authResponse = 102;


    pub fn get_authResponse(&self) -> &AuthMessage {
        self.authResponse.as_ref().unwrap_or_else(|| <AuthMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authResponse(&mut self) {
        self.authResponse.clear();
    }

    pub fn has_authResponse(&self) -> bool {
        self.authResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authResponse(&mut self, v: AuthMessage) {
        self.authResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authResponse(&mut self) -> &mut AuthMessage {
        if self.authResponse.is_none() {
            self.authResponse.set_default();
        }
        self.authResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_authResponse(&mut self) -> AuthMessage {
        self.authResponse.take().unwrap_or_else(|| AuthMessage::new())
    }

    // optional .bk.proto.WriteLacResponse writeLacResponse = 103;


    pub fn get_writeLacResponse(&self) -> &WriteLacResponse {
        self.writeLacResponse.as_ref().unwrap_or_else(|| <WriteLacResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_writeLacResponse(&mut self) {
        self.writeLacResponse.clear();
    }

    pub fn has_writeLacResponse(&self) -> bool {
        self.writeLacResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writeLacResponse(&mut self, v: WriteLacResponse) {
        self.writeLacResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_writeLacResponse(&mut self) -> &mut WriteLacResponse {
        if self.writeLacResponse.is_none() {
            self.writeLacResponse.set_default();
        }
        self.writeLacResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_writeLacResponse(&mut self) -> WriteLacResponse {
        self.writeLacResponse.take().unwrap_or_else(|| WriteLacResponse::new())
    }

    // optional .bk.proto.ReadLacResponse readLacResponse = 104;


    pub fn get_readLacResponse(&self) -> &ReadLacResponse {
        self.readLacResponse.as_ref().unwrap_or_else(|| <ReadLacResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readLacResponse(&mut self) {
        self.readLacResponse.clear();
    }

    pub fn has_readLacResponse(&self) -> bool {
        self.readLacResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readLacResponse(&mut self, v: ReadLacResponse) {
        self.readLacResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readLacResponse(&mut self) -> &mut ReadLacResponse {
        if self.readLacResponse.is_none() {
            self.readLacResponse.set_default();
        }
        self.readLacResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_readLacResponse(&mut self) -> ReadLacResponse {
        self.readLacResponse.take().unwrap_or_else(|| ReadLacResponse::new())
    }

    // optional .bk.proto.GetBookieInfoResponse getBookieInfoResponse = 105;


    pub fn get_getBookieInfoResponse(&self) -> &GetBookieInfoResponse {
        self.getBookieInfoResponse.as_ref().unwrap_or_else(|| <GetBookieInfoResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getBookieInfoResponse(&mut self) {
        self.getBookieInfoResponse.clear();
    }

    pub fn has_getBookieInfoResponse(&self) -> bool {
        self.getBookieInfoResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getBookieInfoResponse(&mut self, v: GetBookieInfoResponse) {
        self.getBookieInfoResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getBookieInfoResponse(&mut self) -> &mut GetBookieInfoResponse {
        if self.getBookieInfoResponse.is_none() {
            self.getBookieInfoResponse.set_default();
        }
        self.getBookieInfoResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_getBookieInfoResponse(&mut self) -> GetBookieInfoResponse {
        self.getBookieInfoResponse.take().unwrap_or_else(|| GetBookieInfoResponse::new())
    }

    // optional .bk.proto.StartTLSResponse startTLSResponse = 106;


    pub fn get_startTLSResponse(&self) -> &StartTLSResponse {
        self.startTLSResponse.as_ref().unwrap_or_else(|| <StartTLSResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_startTLSResponse(&mut self) {
        self.startTLSResponse.clear();
    }

    pub fn has_startTLSResponse(&self) -> bool {
        self.startTLSResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTLSResponse(&mut self, v: StartTLSResponse) {
        self.startTLSResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startTLSResponse(&mut self) -> &mut StartTLSResponse {
        if self.startTLSResponse.is_none() {
            self.startTLSResponse.set_default();
        }
        self.startTLSResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_startTLSResponse(&mut self) -> StartTLSResponse {
        self.startTLSResponse.take().unwrap_or_else(|| StartTLSResponse::new())
    }

    // optional .bk.proto.ForceLedgerResponse forceLedgerResponse = 107;


    pub fn get_forceLedgerResponse(&self) -> &ForceLedgerResponse {
        self.forceLedgerResponse.as_ref().unwrap_or_else(|| <ForceLedgerResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_forceLedgerResponse(&mut self) {
        self.forceLedgerResponse.clear();
    }

    pub fn has_forceLedgerResponse(&self) -> bool {
        self.forceLedgerResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forceLedgerResponse(&mut self, v: ForceLedgerResponse) {
        self.forceLedgerResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forceLedgerResponse(&mut self) -> &mut ForceLedgerResponse {
        if self.forceLedgerResponse.is_none() {
            self.forceLedgerResponse.set_default();
        }
        self.forceLedgerResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_forceLedgerResponse(&mut self) -> ForceLedgerResponse {
        self.forceLedgerResponse.take().unwrap_or_else(|| ForceLedgerResponse::new())
    }

    // optional .bk.proto.GetListOfEntriesOfLedgerResponse getListOfEntriesOfLedgerResponse = 108;


    pub fn get_getListOfEntriesOfLedgerResponse(&self) -> &GetListOfEntriesOfLedgerResponse {
        self.getListOfEntriesOfLedgerResponse.as_ref().unwrap_or_else(|| <GetListOfEntriesOfLedgerResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getListOfEntriesOfLedgerResponse(&mut self) {
        self.getListOfEntriesOfLedgerResponse.clear();
    }

    pub fn has_getListOfEntriesOfLedgerResponse(&self) -> bool {
        self.getListOfEntriesOfLedgerResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getListOfEntriesOfLedgerResponse(&mut self, v: GetListOfEntriesOfLedgerResponse) {
        self.getListOfEntriesOfLedgerResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getListOfEntriesOfLedgerResponse(&mut self) -> &mut GetListOfEntriesOfLedgerResponse {
        if self.getListOfEntriesOfLedgerResponse.is_none() {
            self.getListOfEntriesOfLedgerResponse.set_default();
        }
        self.getListOfEntriesOfLedgerResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_getListOfEntriesOfLedgerResponse(&mut self) -> GetListOfEntriesOfLedgerResponse {
        self.getListOfEntriesOfLedgerResponse.take().unwrap_or_else(|| GetListOfEntriesOfLedgerResponse::new())
    }
}

impl ::protobuf::Message for Response {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.status.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.addResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.writeLacResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readLacResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getBookieInfoResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.startTLSResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.forceLedgerResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getListOfEntriesOfLedgerResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 2, &mut self.unknown_fields)?
                },
                100 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readResponse)?;
                },
                101 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addResponse)?;
                },
                102 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authResponse)?;
                },
                103 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.writeLacResponse)?;
                },
                104 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readLacResponse)?;
                },
                105 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getBookieInfoResponse)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startTLSResponse)?;
                },
                107 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.forceLedgerResponse)?;
                },
                108 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getListOfEntriesOfLedgerResponse)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.readResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.addResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.writeLacResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readLacResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getBookieInfoResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.startTLSResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.forceLedgerResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getListOfEntriesOfLedgerResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.status {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.readResponse.as_ref() {
            os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.addResponse.as_ref() {
            os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authResponse.as_ref() {
            os.write_tag(102, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.writeLacResponse.as_ref() {
            os.write_tag(103, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readLacResponse.as_ref() {
            os.write_tag(104, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getBookieInfoResponse.as_ref() {
            os.write_tag(105, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.startTLSResponse.as_ref() {
            os.write_tag(106, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.forceLedgerResponse.as_ref() {
            os.write_tag(107, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getListOfEntriesOfLedgerResponse.as_ref() {
            os.write_tag(108, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response {
        Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BKPacketHeader>>(
                "header",
                |m: &Response| { &m.header },
                |m: &mut Response| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatusCode>>(
                "status",
                |m: &Response| { &m.status },
                |m: &mut Response| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadResponse>>(
                "readResponse",
                |m: &Response| { &m.readResponse },
                |m: &mut Response| { &mut m.readResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddResponse>>(
                "addResponse",
                |m: &Response| { &m.addResponse },
                |m: &mut Response| { &mut m.addResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthMessage>>(
                "authResponse",
                |m: &Response| { &m.authResponse },
                |m: &mut Response| { &mut m.authResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WriteLacResponse>>(
                "writeLacResponse",
                |m: &Response| { &m.writeLacResponse },
                |m: &mut Response| { &mut m.writeLacResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadLacResponse>>(
                "readLacResponse",
                |m: &Response| { &m.readLacResponse },
                |m: &mut Response| { &mut m.readLacResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetBookieInfoResponse>>(
                "getBookieInfoResponse",
                |m: &Response| { &m.getBookieInfoResponse },
                |m: &mut Response| { &mut m.getBookieInfoResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StartTLSResponse>>(
                "startTLSResponse",
                |m: &Response| { &m.startTLSResponse },
                |m: &mut Response| { &mut m.startTLSResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForceLedgerResponse>>(
                "forceLedgerResponse",
                |m: &Response| { &m.forceLedgerResponse },
                |m: &mut Response| { &mut m.forceLedgerResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetListOfEntriesOfLedgerResponse>>(
                "getListOfEntriesOfLedgerResponse",
                |m: &Response| { &m.getListOfEntriesOfLedgerResponse },
                |m: &mut Response| { &mut m.getListOfEntriesOfLedgerResponse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response>(
                "Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response {
        static instance: ::protobuf::rt::LazyV2<Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response::new)
    }
}

impl ::protobuf::Clear for Response {
    fn clear(&mut self) {
        self.header.clear();
        self.status = ::std::option::Option::None;
        self.readResponse.clear();
        self.addResponse.clear();
        self.authResponse.clear();
        self.writeLacResponse.clear();
        self.readLacResponse.clear();
        self.getBookieInfoResponse.clear();
        self.startTLSResponse.clear();
        self.forceLedgerResponse.clear();
        self.getListOfEntriesOfLedgerResponse.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadResponse {
    // message fields
    status: ::std::option::Option<StatusCode>,
    ledgerId: ::std::option::Option<i64>,
    entryId: ::std::option::Option<i64>,
    body: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    maxLAC: ::std::option::Option<i64>,
    lacUpdateTimestamp: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadResponse {
    fn default() -> &'a ReadResponse {
        <ReadResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReadResponse {
    pub fn new() -> ReadResponse {
        ::std::default::Default::default()
    }

    // required .bk.proto.StatusCode status = 1;


    pub fn get_status(&self) -> StatusCode {
        self.status.unwrap_or(StatusCode::EOK)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: StatusCode) {
        self.status = ::std::option::Option::Some(v);
    }

    // required int64 ledgerId = 2;


    pub fn get_ledgerId(&self) -> i64 {
        self.ledgerId.unwrap_or(0)
    }
    pub fn clear_ledgerId(&mut self) {
        self.ledgerId = ::std::option::Option::None;
    }

    pub fn has_ledgerId(&self) -> bool {
        self.ledgerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerId(&mut self, v: i64) {
        self.ledgerId = ::std::option::Option::Some(v);
    }

    // required int64 entryId = 3;


    pub fn get_entryId(&self) -> i64 {
        self.entryId.unwrap_or(0)
    }
    pub fn clear_entryId(&mut self) {
        self.entryId = ::std::option::Option::None;
    }

    pub fn has_entryId(&self) -> bool {
        self.entryId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryId(&mut self, v: i64) {
        self.entryId = ::std::option::Option::Some(v);
    }

    // optional bytes body = 4;


    pub fn get_body(&self) -> &[u8] {
        match self.body.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        self.body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int64 maxLAC = 5;


    pub fn get_maxLAC(&self) -> i64 {
        self.maxLAC.unwrap_or(0)
    }
    pub fn clear_maxLAC(&mut self) {
        self.maxLAC = ::std::option::Option::None;
    }

    pub fn has_maxLAC(&self) -> bool {
        self.maxLAC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxLAC(&mut self, v: i64) {
        self.maxLAC = ::std::option::Option::Some(v);
    }

    // optional int64 lacUpdateTimestamp = 6;


    pub fn get_lacUpdateTimestamp(&self) -> i64 {
        self.lacUpdateTimestamp.unwrap_or(0)
    }
    pub fn clear_lacUpdateTimestamp(&mut self) {
        self.lacUpdateTimestamp = ::std::option::Option::None;
    }

    pub fn has_lacUpdateTimestamp(&self) -> bool {
        self.lacUpdateTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lacUpdateTimestamp(&mut self, v: i64) {
        self.lacUpdateTimestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ReadResponse {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.ledgerId.is_none() {
            return false;
        }
        if self.entryId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ledgerId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.entryId = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.body)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.maxLAC = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lacUpdateTimestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.ledgerId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entryId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.maxLAC {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lacUpdateTimestamp {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.ledgerId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.entryId {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.maxLAC {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.lacUpdateTimestamp {
            os.write_int64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadResponse {
        ReadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatusCode>>(
                "status",
                |m: &ReadResponse| { &m.status },
                |m: &mut ReadResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ledgerId",
                |m: &ReadResponse| { &m.ledgerId },
                |m: &mut ReadResponse| { &mut m.ledgerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "entryId",
                |m: &ReadResponse| { &m.entryId },
                |m: &mut ReadResponse| { &mut m.entryId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "body",
                |m: &ReadResponse| { &m.body },
                |m: &mut ReadResponse| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "maxLAC",
                |m: &ReadResponse| { &m.maxLAC },
                |m: &mut ReadResponse| { &mut m.maxLAC },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lacUpdateTimestamp",
                |m: &ReadResponse| { &m.lacUpdateTimestamp },
                |m: &mut ReadResponse| { &mut m.lacUpdateTimestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadResponse>(
                "ReadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadResponse {
        static instance: ::protobuf::rt::LazyV2<ReadResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadResponse::new)
    }
}

impl ::protobuf::Clear for ReadResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.ledgerId = ::std::option::Option::None;
        self.entryId = ::std::option::Option::None;
        self.body.clear();
        self.maxLAC = ::std::option::Option::None;
        self.lacUpdateTimestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddResponse {
    // message fields
    status: ::std::option::Option<StatusCode>,
    ledgerId: ::std::option::Option<i64>,
    entryId: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddResponse {
    fn default() -> &'a AddResponse {
        <AddResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddResponse {
    pub fn new() -> AddResponse {
        ::std::default::Default::default()
    }

    // required .bk.proto.StatusCode status = 1;


    pub fn get_status(&self) -> StatusCode {
        self.status.unwrap_or(StatusCode::EOK)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: StatusCode) {
        self.status = ::std::option::Option::Some(v);
    }

    // required int64 ledgerId = 2;


    pub fn get_ledgerId(&self) -> i64 {
        self.ledgerId.unwrap_or(0)
    }
    pub fn clear_ledgerId(&mut self) {
        self.ledgerId = ::std::option::Option::None;
    }

    pub fn has_ledgerId(&self) -> bool {
        self.ledgerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerId(&mut self, v: i64) {
        self.ledgerId = ::std::option::Option::Some(v);
    }

    // required int64 entryId = 3;


    pub fn get_entryId(&self) -> i64 {
        self.entryId.unwrap_or(0)
    }
    pub fn clear_entryId(&mut self) {
        self.entryId = ::std::option::Option::None;
    }

    pub fn has_entryId(&self) -> bool {
        self.entryId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryId(&mut self, v: i64) {
        self.entryId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AddResponse {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.ledgerId.is_none() {
            return false;
        }
        if self.entryId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ledgerId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.entryId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.ledgerId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entryId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.ledgerId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.entryId {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddResponse {
        AddResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatusCode>>(
                "status",
                |m: &AddResponse| { &m.status },
                |m: &mut AddResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ledgerId",
                |m: &AddResponse| { &m.ledgerId },
                |m: &mut AddResponse| { &mut m.ledgerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "entryId",
                |m: &AddResponse| { &m.entryId },
                |m: &mut AddResponse| { &mut m.entryId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddResponse>(
                "AddResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddResponse {
        static instance: ::protobuf::rt::LazyV2<AddResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddResponse::new)
    }
}

impl ::protobuf::Clear for AddResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.ledgerId = ::std::option::Option::None;
        self.entryId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthMessage {
    // message fields
    authPluginName: ::protobuf::SingularField<::std::string::String>,
    payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthMessage {
    fn default() -> &'a AuthMessage {
        <AuthMessage as ::protobuf::Message>::default_instance()
    }
}

impl AuthMessage {
    pub fn new() -> AuthMessage {
        ::std::default::Default::default()
    }

    // required string authPluginName = 1;


    pub fn get_authPluginName(&self) -> &str {
        match self.authPluginName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_authPluginName(&mut self) {
        self.authPluginName.clear();
    }

    pub fn has_authPluginName(&self) -> bool {
        self.authPluginName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authPluginName(&mut self, v: ::std::string::String) {
        self.authPluginName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authPluginName(&mut self) -> &mut ::std::string::String {
        if self.authPluginName.is_none() {
            self.authPluginName.set_default();
        }
        self.authPluginName.as_mut().unwrap()
    }

    // Take field
    pub fn take_authPluginName(&mut self) -> ::std::string::String {
        self.authPluginName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes payload = 2;


    pub fn get_payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AuthMessage {
    fn is_initialized(&self) -> bool {
        if self.authPluginName.is_none() {
            return false;
        }
        if self.payload.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.authPluginName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.authPluginName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.authPluginName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthMessage {
        AuthMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authPluginName",
                |m: &AuthMessage| { &m.authPluginName },
                |m: &mut AuthMessage| { &mut m.authPluginName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payload",
                |m: &AuthMessage| { &m.payload },
                |m: &mut AuthMessage| { &mut m.payload },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthMessage>(
                "AuthMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthMessage {
        static instance: ::protobuf::rt::LazyV2<AuthMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthMessage::new)
    }
}

impl ::protobuf::Clear for AuthMessage {
    fn clear(&mut self) {
        self.authPluginName.clear();
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteLacResponse {
    // message fields
    status: ::std::option::Option<StatusCode>,
    ledgerId: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteLacResponse {
    fn default() -> &'a WriteLacResponse {
        <WriteLacResponse as ::protobuf::Message>::default_instance()
    }
}

impl WriteLacResponse {
    pub fn new() -> WriteLacResponse {
        ::std::default::Default::default()
    }

    // required .bk.proto.StatusCode status = 1;


    pub fn get_status(&self) -> StatusCode {
        self.status.unwrap_or(StatusCode::EOK)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: StatusCode) {
        self.status = ::std::option::Option::Some(v);
    }

    // required int64 ledgerId = 2;


    pub fn get_ledgerId(&self) -> i64 {
        self.ledgerId.unwrap_or(0)
    }
    pub fn clear_ledgerId(&mut self) {
        self.ledgerId = ::std::option::Option::None;
    }

    pub fn has_ledgerId(&self) -> bool {
        self.ledgerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerId(&mut self, v: i64) {
        self.ledgerId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for WriteLacResponse {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.ledgerId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ledgerId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.ledgerId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.ledgerId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteLacResponse {
        WriteLacResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatusCode>>(
                "status",
                |m: &WriteLacResponse| { &m.status },
                |m: &mut WriteLacResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ledgerId",
                |m: &WriteLacResponse| { &m.ledgerId },
                |m: &mut WriteLacResponse| { &mut m.ledgerId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WriteLacResponse>(
                "WriteLacResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WriteLacResponse {
        static instance: ::protobuf::rt::LazyV2<WriteLacResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WriteLacResponse::new)
    }
}

impl ::protobuf::Clear for WriteLacResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.ledgerId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteLacResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteLacResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ForceLedgerResponse {
    // message fields
    status: ::std::option::Option<StatusCode>,
    ledgerId: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForceLedgerResponse {
    fn default() -> &'a ForceLedgerResponse {
        <ForceLedgerResponse as ::protobuf::Message>::default_instance()
    }
}

impl ForceLedgerResponse {
    pub fn new() -> ForceLedgerResponse {
        ::std::default::Default::default()
    }

    // required .bk.proto.StatusCode status = 1;


    pub fn get_status(&self) -> StatusCode {
        self.status.unwrap_or(StatusCode::EOK)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: StatusCode) {
        self.status = ::std::option::Option::Some(v);
    }

    // required int64 ledgerId = 2;


    pub fn get_ledgerId(&self) -> i64 {
        self.ledgerId.unwrap_or(0)
    }
    pub fn clear_ledgerId(&mut self) {
        self.ledgerId = ::std::option::Option::None;
    }

    pub fn has_ledgerId(&self) -> bool {
        self.ledgerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerId(&mut self, v: i64) {
        self.ledgerId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ForceLedgerResponse {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.ledgerId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ledgerId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.ledgerId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.ledgerId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForceLedgerResponse {
        ForceLedgerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatusCode>>(
                "status",
                |m: &ForceLedgerResponse| { &m.status },
                |m: &mut ForceLedgerResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ledgerId",
                |m: &ForceLedgerResponse| { &m.ledgerId },
                |m: &mut ForceLedgerResponse| { &mut m.ledgerId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ForceLedgerResponse>(
                "ForceLedgerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ForceLedgerResponse {
        static instance: ::protobuf::rt::LazyV2<ForceLedgerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ForceLedgerResponse::new)
    }
}

impl ::protobuf::Clear for ForceLedgerResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.ledgerId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForceLedgerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForceLedgerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadLacResponse {
    // message fields
    status: ::std::option::Option<StatusCode>,
    ledgerId: ::std::option::Option<i64>,
    lacBody: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    lastEntryBody: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadLacResponse {
    fn default() -> &'a ReadLacResponse {
        <ReadLacResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReadLacResponse {
    pub fn new() -> ReadLacResponse {
        ::std::default::Default::default()
    }

    // required .bk.proto.StatusCode status = 1;


    pub fn get_status(&self) -> StatusCode {
        self.status.unwrap_or(StatusCode::EOK)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: StatusCode) {
        self.status = ::std::option::Option::Some(v);
    }

    // required int64 ledgerId = 2;


    pub fn get_ledgerId(&self) -> i64 {
        self.ledgerId.unwrap_or(0)
    }
    pub fn clear_ledgerId(&mut self) {
        self.ledgerId = ::std::option::Option::None;
    }

    pub fn has_ledgerId(&self) -> bool {
        self.ledgerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerId(&mut self, v: i64) {
        self.ledgerId = ::std::option::Option::Some(v);
    }

    // optional bytes lacBody = 3;


    pub fn get_lacBody(&self) -> &[u8] {
        match self.lacBody.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_lacBody(&mut self) {
        self.lacBody.clear();
    }

    pub fn has_lacBody(&self) -> bool {
        self.lacBody.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lacBody(&mut self, v: ::std::vec::Vec<u8>) {
        self.lacBody = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lacBody(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.lacBody.is_none() {
            self.lacBody.set_default();
        }
        self.lacBody.as_mut().unwrap()
    }

    // Take field
    pub fn take_lacBody(&mut self) -> ::std::vec::Vec<u8> {
        self.lacBody.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes lastEntryBody = 4;


    pub fn get_lastEntryBody(&self) -> &[u8] {
        match self.lastEntryBody.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_lastEntryBody(&mut self) {
        self.lastEntryBody.clear();
    }

    pub fn has_lastEntryBody(&self) -> bool {
        self.lastEntryBody.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastEntryBody(&mut self, v: ::std::vec::Vec<u8>) {
        self.lastEntryBody = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastEntryBody(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.lastEntryBody.is_none() {
            self.lastEntryBody.set_default();
        }
        self.lastEntryBody.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastEntryBody(&mut self) -> ::std::vec::Vec<u8> {
        self.lastEntryBody.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReadLacResponse {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.ledgerId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ledgerId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.lacBody)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.lastEntryBody)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.ledgerId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.lacBody.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.lastEntryBody.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.ledgerId {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.lacBody.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.lastEntryBody.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadLacResponse {
        ReadLacResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatusCode>>(
                "status",
                |m: &ReadLacResponse| { &m.status },
                |m: &mut ReadLacResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ledgerId",
                |m: &ReadLacResponse| { &m.ledgerId },
                |m: &mut ReadLacResponse| { &mut m.ledgerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "lacBody",
                |m: &ReadLacResponse| { &m.lacBody },
                |m: &mut ReadLacResponse| { &mut m.lacBody },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "lastEntryBody",
                |m: &ReadLacResponse| { &m.lastEntryBody },
                |m: &mut ReadLacResponse| { &mut m.lastEntryBody },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadLacResponse>(
                "ReadLacResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadLacResponse {
        static instance: ::protobuf::rt::LazyV2<ReadLacResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadLacResponse::new)
    }
}

impl ::protobuf::Clear for ReadLacResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.ledgerId = ::std::option::Option::None;
        self.lacBody.clear();
        self.lastEntryBody.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadLacResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadLacResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBookieInfoResponse {
    // message fields
    status: ::std::option::Option<StatusCode>,
    totalDiskCapacity: ::std::option::Option<i64>,
    freeDiskSpace: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBookieInfoResponse {
    fn default() -> &'a GetBookieInfoResponse {
        <GetBookieInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBookieInfoResponse {
    pub fn new() -> GetBookieInfoResponse {
        ::std::default::Default::default()
    }

    // required .bk.proto.StatusCode status = 1;


    pub fn get_status(&self) -> StatusCode {
        self.status.unwrap_or(StatusCode::EOK)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: StatusCode) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional int64 totalDiskCapacity = 2;


    pub fn get_totalDiskCapacity(&self) -> i64 {
        self.totalDiskCapacity.unwrap_or(0)
    }
    pub fn clear_totalDiskCapacity(&mut self) {
        self.totalDiskCapacity = ::std::option::Option::None;
    }

    pub fn has_totalDiskCapacity(&self) -> bool {
        self.totalDiskCapacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_totalDiskCapacity(&mut self, v: i64) {
        self.totalDiskCapacity = ::std::option::Option::Some(v);
    }

    // optional int64 freeDiskSpace = 3;


    pub fn get_freeDiskSpace(&self) -> i64 {
        self.freeDiskSpace.unwrap_or(0)
    }
    pub fn clear_freeDiskSpace(&mut self) {
        self.freeDiskSpace = ::std::option::Option::None;
    }

    pub fn has_freeDiskSpace(&self) -> bool {
        self.freeDiskSpace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_freeDiskSpace(&mut self, v: i64) {
        self.freeDiskSpace = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetBookieInfoResponse {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalDiskCapacity = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.freeDiskSpace = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.totalDiskCapacity {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.freeDiskSpace {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.totalDiskCapacity {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.freeDiskSpace {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBookieInfoResponse {
        GetBookieInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatusCode>>(
                "status",
                |m: &GetBookieInfoResponse| { &m.status },
                |m: &mut GetBookieInfoResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "totalDiskCapacity",
                |m: &GetBookieInfoResponse| { &m.totalDiskCapacity },
                |m: &mut GetBookieInfoResponse| { &mut m.totalDiskCapacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "freeDiskSpace",
                |m: &GetBookieInfoResponse| { &m.freeDiskSpace },
                |m: &mut GetBookieInfoResponse| { &mut m.freeDiskSpace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBookieInfoResponse>(
                "GetBookieInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBookieInfoResponse {
        static instance: ::protobuf::rt::LazyV2<GetBookieInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBookieInfoResponse::new)
    }
}

impl ::protobuf::Clear for GetBookieInfoResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.totalDiskCapacity = ::std::option::Option::None;
        self.freeDiskSpace = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBookieInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBookieInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetListOfEntriesOfLedgerResponse {
    // message fields
    status: ::std::option::Option<StatusCode>,
    ledgerId: ::std::option::Option<i64>,
    availabilityOfEntriesOfLedger: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetListOfEntriesOfLedgerResponse {
    fn default() -> &'a GetListOfEntriesOfLedgerResponse {
        <GetListOfEntriesOfLedgerResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetListOfEntriesOfLedgerResponse {
    pub fn new() -> GetListOfEntriesOfLedgerResponse {
        ::std::default::Default::default()
    }

    // required .bk.proto.StatusCode status = 1;


    pub fn get_status(&self) -> StatusCode {
        self.status.unwrap_or(StatusCode::EOK)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: StatusCode) {
        self.status = ::std::option::Option::Some(v);
    }

    // required int64 ledgerId = 2;


    pub fn get_ledgerId(&self) -> i64 {
        self.ledgerId.unwrap_or(0)
    }
    pub fn clear_ledgerId(&mut self) {
        self.ledgerId = ::std::option::Option::None;
    }

    pub fn has_ledgerId(&self) -> bool {
        self.ledgerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerId(&mut self, v: i64) {
        self.ledgerId = ::std::option::Option::Some(v);
    }

    // optional bytes availabilityOfEntriesOfLedger = 3;


    pub fn get_availabilityOfEntriesOfLedger(&self) -> &[u8] {
        match self.availabilityOfEntriesOfLedger.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_availabilityOfEntriesOfLedger(&mut self) {
        self.availabilityOfEntriesOfLedger.clear();
    }

    pub fn has_availabilityOfEntriesOfLedger(&self) -> bool {
        self.availabilityOfEntriesOfLedger.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availabilityOfEntriesOfLedger(&mut self, v: ::std::vec::Vec<u8>) {
        self.availabilityOfEntriesOfLedger = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_availabilityOfEntriesOfLedger(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.availabilityOfEntriesOfLedger.is_none() {
            self.availabilityOfEntriesOfLedger.set_default();
        }
        self.availabilityOfEntriesOfLedger.as_mut().unwrap()
    }

    // Take field
    pub fn take_availabilityOfEntriesOfLedger(&mut self) -> ::std::vec::Vec<u8> {
        self.availabilityOfEntriesOfLedger.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetListOfEntriesOfLedgerResponse {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.ledgerId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ledgerId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.availabilityOfEntriesOfLedger)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.ledgerId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.availabilityOfEntriesOfLedger.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.ledgerId {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.availabilityOfEntriesOfLedger.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetListOfEntriesOfLedgerResponse {
        GetListOfEntriesOfLedgerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatusCode>>(
                "status",
                |m: &GetListOfEntriesOfLedgerResponse| { &m.status },
                |m: &mut GetListOfEntriesOfLedgerResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ledgerId",
                |m: &GetListOfEntriesOfLedgerResponse| { &m.ledgerId },
                |m: &mut GetListOfEntriesOfLedgerResponse| { &mut m.ledgerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "availabilityOfEntriesOfLedger",
                |m: &GetListOfEntriesOfLedgerResponse| { &m.availabilityOfEntriesOfLedger },
                |m: &mut GetListOfEntriesOfLedgerResponse| { &mut m.availabilityOfEntriesOfLedger },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetListOfEntriesOfLedgerResponse>(
                "GetListOfEntriesOfLedgerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetListOfEntriesOfLedgerResponse {
        static instance: ::protobuf::rt::LazyV2<GetListOfEntriesOfLedgerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetListOfEntriesOfLedgerResponse::new)
    }
}

impl ::protobuf::Clear for GetListOfEntriesOfLedgerResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.ledgerId = ::std::option::Option::None;
        self.availabilityOfEntriesOfLedger.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetListOfEntriesOfLedgerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetListOfEntriesOfLedgerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartTLSResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartTLSResponse {
    fn default() -> &'a StartTLSResponse {
        <StartTLSResponse as ::protobuf::Message>::default_instance()
    }
}

impl StartTLSResponse {
    pub fn new() -> StartTLSResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartTLSResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartTLSResponse {
        StartTLSResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartTLSResponse>(
                "StartTLSResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartTLSResponse {
        static instance: ::protobuf::rt::LazyV2<StartTLSResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartTLSResponse::new)
    }
}

impl ::protobuf::Clear for StartTLSResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartTLSResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartTLSResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProtocolVersion {
    VERSION_ONE = 1,
    VERSION_TWO = 2,
    VERSION_THREE = 3,
}

impl ::protobuf::ProtobufEnum for ProtocolVersion {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtocolVersion> {
        match value {
            1 => ::std::option::Option::Some(ProtocolVersion::VERSION_ONE),
            2 => ::std::option::Option::Some(ProtocolVersion::VERSION_TWO),
            3 => ::std::option::Option::Some(ProtocolVersion::VERSION_THREE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProtocolVersion] = &[
            ProtocolVersion::VERSION_ONE,
            ProtocolVersion::VERSION_TWO,
            ProtocolVersion::VERSION_THREE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ProtocolVersion>("ProtocolVersion", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ProtocolVersion {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtocolVersion {
    fn default() -> Self {
        ProtocolVersion::VERSION_ONE
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtocolVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StatusCode {
    EOK = 0,
    ENOLEDGER = 402,
    ENOENTRY = 403,
    EBADREQ = 404,
    EIO = 501,
    EUA = 502,
    EBADVERSION = 503,
    EFENCED = 504,
    EREADONLY = 505,
    ETOOMANYREQUESTS = 506,
}

impl ::protobuf::ProtobufEnum for StatusCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StatusCode> {
        match value {
            0 => ::std::option::Option::Some(StatusCode::EOK),
            402 => ::std::option::Option::Some(StatusCode::ENOLEDGER),
            403 => ::std::option::Option::Some(StatusCode::ENOENTRY),
            404 => ::std::option::Option::Some(StatusCode::EBADREQ),
            501 => ::std::option::Option::Some(StatusCode::EIO),
            502 => ::std::option::Option::Some(StatusCode::EUA),
            503 => ::std::option::Option::Some(StatusCode::EBADVERSION),
            504 => ::std::option::Option::Some(StatusCode::EFENCED),
            505 => ::std::option::Option::Some(StatusCode::EREADONLY),
            506 => ::std::option::Option::Some(StatusCode::ETOOMANYREQUESTS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StatusCode] = &[
            StatusCode::EOK,
            StatusCode::ENOLEDGER,
            StatusCode::ENOENTRY,
            StatusCode::EBADREQ,
            StatusCode::EIO,
            StatusCode::EUA,
            StatusCode::EBADVERSION,
            StatusCode::EFENCED,
            StatusCode::EREADONLY,
            StatusCode::ETOOMANYREQUESTS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<StatusCode>("StatusCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for StatusCode {
}

impl ::std::default::Default for StatusCode {
    fn default() -> Self {
        StatusCode::EOK
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OperationType {
    READ_ENTRY = 1,
    ADD_ENTRY = 2,
    RANGE_READ_ENTRY = 3,
    RANGE_ADD_ENTRY = 4,
    AUTH = 5,
    WRITE_LAC = 6,
    READ_LAC = 7,
    GET_BOOKIE_INFO = 8,
    START_TLS = 9,
    FORCE_LEDGER = 10,
    GET_LIST_OF_ENTRIES_OF_LEDGER = 11,
}

impl ::protobuf::ProtobufEnum for OperationType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OperationType> {
        match value {
            1 => ::std::option::Option::Some(OperationType::READ_ENTRY),
            2 => ::std::option::Option::Some(OperationType::ADD_ENTRY),
            3 => ::std::option::Option::Some(OperationType::RANGE_READ_ENTRY),
            4 => ::std::option::Option::Some(OperationType::RANGE_ADD_ENTRY),
            5 => ::std::option::Option::Some(OperationType::AUTH),
            6 => ::std::option::Option::Some(OperationType::WRITE_LAC),
            7 => ::std::option::Option::Some(OperationType::READ_LAC),
            8 => ::std::option::Option::Some(OperationType::GET_BOOKIE_INFO),
            9 => ::std::option::Option::Some(OperationType::START_TLS),
            10 => ::std::option::Option::Some(OperationType::FORCE_LEDGER),
            11 => ::std::option::Option::Some(OperationType::GET_LIST_OF_ENTRIES_OF_LEDGER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OperationType] = &[
            OperationType::READ_ENTRY,
            OperationType::ADD_ENTRY,
            OperationType::RANGE_READ_ENTRY,
            OperationType::RANGE_ADD_ENTRY,
            OperationType::AUTH,
            OperationType::WRITE_LAC,
            OperationType::READ_LAC,
            OperationType::GET_BOOKIE_INFO,
            OperationType::START_TLS,
            OperationType::FORCE_LEDGER,
            OperationType::GET_LIST_OF_ENTRIES_OF_LEDGER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OperationType>("OperationType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OperationType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for OperationType {
    fn default() -> Self {
        OperationType::READ_ENTRY
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x18BookkeeperProtocol.proto\x12\x08bk.proto\"\xbb\x01\n\x0eBKPacketHe\
    ader\x125\n\x07version\x18\x01\x20\x02(\x0e2\x19.bk.proto.ProtocolVersio\
    nR\x07versionB\0\x127\n\toperation\x18\x02\x20\x02(\x0e2\x17.bk.proto.Op\
    erationTypeR\toperationB\0\x12\x16\n\x05txnId\x18\x03\x20\x02(\x04R\x05t\
    xnIdB\0\x12\x1f\n\x08priority\x18\x04\x20\x01(\r:\x010R\x08priorityB\0:\
    \0\";\n\x0bContextPair\x12\x12\n\x03key\x18\x01\x20\x02(\tR\x03keyB\0\
    \x12\x16\n\x05value\x18\x02\x20\x02(\tR\x05valueB\0:\0\"\x9e\x06\n\x07Re\
    quest\x122\n\x06header\x18\x01\x20\x02(\x0b2\x18.bk.proto.BKPacketHeader\
    R\x06headerB\0\x129\n\x0breadRequest\x18d\x20\x01(\x0b2\x15.bk.proto.Rea\
    dRequestR\x0breadRequestB\0\x126\n\naddRequest\x18e\x20\x01(\x0b2\x14.bk\
    .proto.AddRequestR\naddRequestB\0\x129\n\x0bauthRequest\x18f\x20\x01(\
    \x0b2\x15.bk.proto.AuthMessageR\x0bauthRequestB\0\x12E\n\x0fwriteLacRequ\
    est\x18g\x20\x01(\x0b2\x19.bk.proto.WriteLacRequestR\x0fwriteLacRequestB\
    \0\x12B\n\x0ereadLacRequest\x18h\x20\x01(\x0b2\x18.bk.proto.ReadLacReque\
    stR\x0ereadLacRequestB\0\x12T\n\x14getBookieInfoRequest\x18i\x20\x01(\
    \x0b2\x1e.bk.proto.GetBookieInfoRequestR\x14getBookieInfoRequestB\0\x12E\
    \n\x0fstartTLSRequest\x18j\x20\x01(\x0b2\x19.bk.proto.StartTLSRequestR\
    \x0fstartTLSRequestB\0\x12N\n\x12forceLedgerRequest\x18k\x20\x01(\x0b2\
    \x1c.bk.proto.ForceLedgerRequestR\x12forceLedgerRequestB\0\x12u\n\x1fget\
    ListOfEntriesOfLedgerRequest\x18l\x20\x01(\x0b2).bk.proto.GetListOfEntri\
    esOfLedgerRequestR\x1fgetListOfEntriesOfLedgerRequestB\0\x12@\n\x0ereque\
    stContext\x18\xc8\x01\x20\x03(\x0b2\x15.bk.proto.ContextPairR\x0erequest\
    ContextB\0:\0\"\x8c\x02\n\x0bReadRequest\x120\n\x04flag\x18d\x20\x01(\
    \x0e2\x1a.bk.proto.ReadRequest.FlagR\x04flagB\0\x12\x1c\n\x08ledgerId\
    \x18\x01\x20\x02(\x03R\x08ledgerIdB\0\x12\x1a\n\x07entryId\x18\x02\x20\
    \x02(\x03R\x07entryIdB\0\x12\x1e\n\tmasterKey\x18\x03\x20\x01(\x0cR\tmas\
    terKeyB\0\x12\"\n\x0bpreviousLAC\x18\x04\x20\x01(\x03R\x0bpreviousLACB\0\
    \x12\x1a\n\x07timeOut\x18\x05\x20\x01(\x03R\x07timeOutB\0\"/\n\x04Flag\
    \x12\x10\n\x0cFENCE_LEDGER\x10\x01\x12\x13\n\x0fENTRY_PIGGYBACK\x10\x02\
    \x1a\0:\0\"\xed\x01\n\nAddRequest\x12/\n\x04flag\x18d\x20\x01(\x0e2\x19.\
    bk.proto.AddRequest.FlagR\x04flagB\0\x12\x1c\n\x08ledgerId\x18\x01\x20\
    \x02(\x03R\x08ledgerIdB\0\x12\x1a\n\x07entryId\x18\x02\x20\x02(\x03R\x07\
    entryIdB\0\x12\x1e\n\tmasterKey\x18\x03\x20\x02(\x0cR\tmasterKeyB\0\x12\
    \x14\n\x04body\x18\x04\x20\x02(\x0cR\x04bodyB\0\x12\x20\n\nwriteFlags\
    \x18\x05\x20\x01(\x05R\nwriteFlagsB\0\"\x1a\n\x04Flag\x12\x10\n\x0cRECOV\
    ERY_ADD\x10\x01\x1a\0:\0\"\x13\n\x0fStartTLSRequest:\0\"{\n\x0fWriteLacR\
    equest\x12\x1c\n\x08ledgerId\x18\x01\x20\x02(\x03R\x08ledgerIdB\0\x12\
    \x12\n\x03lac\x18\x02\x20\x02(\x03R\x03lacB\0\x12\x1e\n\tmasterKey\x18\
    \x03\x20\x02(\x0cR\tmasterKeyB\0\x12\x14\n\x04body\x18\x04\x20\x02(\x0cR\
    \x04bodyB\0:\0\"4\n\x12ForceLedgerRequest\x12\x1c\n\x08ledgerId\x18\x01\
    \x20\x02(\x03R\x08ledgerIdB\0:\0\"0\n\x0eReadLacRequest\x12\x1c\n\x08led\
    gerId\x18\x01\x20\x02(\x03R\x08ledgerIdB\0:\0\"q\n\x14GetBookieInfoReque\
    st\x12\x1e\n\trequested\x18\x01\x20\x01(\x03R\trequestedB\0\"7\n\x05Flag\
    s\x12\x17\n\x13TOTAL_DISK_CAPACITY\x10\x01\x12\x13\n\x0fFREE_DISK_SPACE\
    \x10\x02\x1a\0:\0\"A\n\x1fGetListOfEntriesOfLedgerRequest\x12\x1c\n\x08l\
    edgerId\x18\x01\x20\x02(\x03R\x08ledgerIdB\0:\0\"\xa7\x06\n\x08Response\
    \x122\n\x06header\x18\x01\x20\x02(\x0b2\x18.bk.proto.BKPacketHeaderR\x06\
    headerB\0\x12.\n\x06status\x18\x02\x20\x02(\x0e2\x14.bk.proto.StatusCode\
    R\x06statusB\0\x12<\n\x0creadResponse\x18d\x20\x01(\x0b2\x16.bk.proto.Re\
    adResponseR\x0creadResponseB\0\x129\n\x0baddResponse\x18e\x20\x01(\x0b2\
    \x15.bk.proto.AddResponseR\x0baddResponseB\0\x12;\n\x0cauthResponse\x18f\
    \x20\x01(\x0b2\x15.bk.proto.AuthMessageR\x0cauthResponseB\0\x12H\n\x10wr\
    iteLacResponse\x18g\x20\x01(\x0b2\x1a.bk.proto.WriteLacResponseR\x10writ\
    eLacResponseB\0\x12E\n\x0freadLacResponse\x18h\x20\x01(\x0b2\x19.bk.prot\
    o.ReadLacResponseR\x0freadLacResponseB\0\x12W\n\x15getBookieInfoResponse\
    \x18i\x20\x01(\x0b2\x1f.bk.proto.GetBookieInfoResponseR\x15getBookieInfo\
    ResponseB\0\x12H\n\x10startTLSResponse\x18j\x20\x01(\x0b2\x1a.bk.proto.S\
    tartTLSResponseR\x10startTLSResponseB\0\x12Q\n\x13forceLedgerResponse\
    \x18k\x20\x01(\x0b2\x1d.bk.proto.ForceLedgerResponseR\x13forceLedgerResp\
    onseB\0\x12x\n\x20getListOfEntriesOfLedgerResponse\x18l\x20\x01(\x0b2*.b\
    k.proto.GetListOfEntriesOfLedgerResponseR\x20getListOfEntriesOfLedgerRes\
    ponseB\0:\0\"\xdc\x01\n\x0cReadResponse\x12.\n\x06status\x18\x01\x20\x02\
    (\x0e2\x14.bk.proto.StatusCodeR\x06statusB\0\x12\x1c\n\x08ledgerId\x18\
    \x02\x20\x02(\x03R\x08ledgerIdB\0\x12\x1a\n\x07entryId\x18\x03\x20\x02(\
    \x03R\x07entryIdB\0\x12\x14\n\x04body\x18\x04\x20\x01(\x0cR\x04bodyB\0\
    \x12\x18\n\x06maxLAC\x18\x05\x20\x01(\x03R\x06maxLACB\0\x120\n\x12lacUpd\
    ateTimestamp\x18\x06\x20\x01(\x03R\x12lacUpdateTimestampB\0:\0\"y\n\x0bA\
    ddResponse\x12.\n\x06status\x18\x01\x20\x02(\x0e2\x14.bk.proto.StatusCod\
    eR\x06statusB\0\x12\x1c\n\x08ledgerId\x18\x02\x20\x02(\x03R\x08ledgerIdB\
    \0\x12\x1a\n\x07entryId\x18\x03\x20\x02(\x03R\x07entryIdB\0:\0\"U\n\x0bA\
    uthMessage\x12(\n\x0eauthPluginName\x18\x01\x20\x02(\tR\x0eauthPluginNam\
    eB\0\x12\x1a\n\x07payload\x18\x02\x20\x02(\x0cR\x07payloadB\0:\0\"b\n\
    \x10WriteLacResponse\x12.\n\x06status\x18\x01\x20\x02(\x0e2\x14.bk.proto\
    .StatusCodeR\x06statusB\0\x12\x1c\n\x08ledgerId\x18\x02\x20\x02(\x03R\
    \x08ledgerIdB\0:\0\"e\n\x13ForceLedgerResponse\x12.\n\x06status\x18\x01\
    \x20\x02(\x0e2\x14.bk.proto.StatusCodeR\x06statusB\0\x12\x1c\n\x08ledger\
    Id\x18\x02\x20\x02(\x03R\x08ledgerIdB\0:\0\"\xa5\x01\n\x0fReadLacRespons\
    e\x12.\n\x06status\x18\x01\x20\x02(\x0e2\x14.bk.proto.StatusCodeR\x06sta\
    tusB\0\x12\x1c\n\x08ledgerId\x18\x02\x20\x02(\x03R\x08ledgerIdB\0\x12\
    \x1a\n\x07lacBody\x18\x03\x20\x01(\x0cR\x07lacBodyB\0\x12&\n\rlastEntryB\
    ody\x18\x04\x20\x01(\x0cR\rlastEntryBodyB\0:\0\"\xa1\x01\n\x15GetBookieI\
    nfoResponse\x12.\n\x06status\x18\x01\x20\x02(\x0e2\x14.bk.proto.StatusCo\
    deR\x06statusB\0\x12.\n\x11totalDiskCapacity\x18\x02\x20\x01(\x03R\x11to\
    talDiskCapacityB\0\x12&\n\rfreeDiskSpace\x18\x03\x20\x01(\x03R\rfreeDisk\
    SpaceB\0:\0\"\xba\x01\n\x20GetListOfEntriesOfLedgerResponse\x12.\n\x06st\
    atus\x18\x01\x20\x02(\x0e2\x14.bk.proto.StatusCodeR\x06statusB\0\x12\x1c\
    \n\x08ledgerId\x18\x02\x20\x02(\x03R\x08ledgerIdB\0\x12F\n\x1davailabili\
    tyOfEntriesOfLedger\x18\x03\x20\x01(\x0cR\x1davailabilityOfEntriesOfLedg\
    erB\0:\0\"\x14\n\x10StartTLSResponse:\0*H\n\x0fProtocolVersion\x12\x0f\n\
    \x0bVERSION_ONE\x10\x01\x12\x0f\n\x0bVERSION_TWO\x10\x02\x12\x11\n\rVERS\
    ION_THREE\x10\x03\x1a\0*\x9f\x01\n\nStatusCode\x12\x07\n\x03EOK\x10\0\
    \x12\x0e\n\tENOLEDGER\x10\x92\x03\x12\r\n\x08ENOENTRY\x10\x93\x03\x12\
    \x0c\n\x07EBADREQ\x10\x94\x03\x12\x08\n\x03EIO\x10\xf5\x03\x12\x08\n\x03\
    EUA\x10\xf6\x03\x12\x10\n\x0bEBADVERSION\x10\xf7\x03\x12\x0c\n\x07EFENCE\
    D\x10\xf8\x03\x12\x0e\n\tEREADONLY\x10\xf9\x03\x12\x15\n\x10ETOOMANYREQU\
    ESTS\x10\xfa\x03\x1a\0*\xdb\x01\n\rOperationType\x12\x0e\n\nREAD_ENTRY\
    \x10\x01\x12\r\n\tADD_ENTRY\x10\x02\x12\x14\n\x10RANGE_READ_ENTRY\x10\
    \x03\x12\x13\n\x0fRANGE_ADD_ENTRY\x10\x04\x12\x08\n\x04AUTH\x10\x05\x12\
    \r\n\tWRITE_LAC\x10\x06\x12\x0c\n\x08READ_LAC\x10\x07\x12\x13\n\x0fGET_B\
    OOKIE_INFO\x10\x08\x12\r\n\tSTART_TLS\x10\t\x12\x10\n\x0cFORCE_LEDGER\
    \x10\n\x12!\n\x1dGET_LIST_OF_ENTRIES_OF_LEDGER\x10\x0b\x1a\0B\0b\x06prot\
    o2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
