// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `DataFormats.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct LedgerMetadataFormat {
    // message fields
    quorumSize: ::std::option::Option<i32>,
    ensembleSize: ::std::option::Option<i32>,
    length: ::std::option::Option<i64>,
    lastEntryId: ::std::option::Option<i64>,
    state: ::std::option::Option<LedgerMetadataFormat_State>,
    pub segment: ::protobuf::RepeatedField<LedgerMetadataFormat_Segment>,
    digestType: ::std::option::Option<LedgerMetadataFormat_DigestType>,
    password: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ackQuorumSize: ::std::option::Option<i32>,
    ctime: ::std::option::Option<i64>,
    pub customMetadata: ::protobuf::RepeatedField<LedgerMetadataFormat_cMetadataMapEntry>,
    cToken: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LedgerMetadataFormat {
    fn default() -> &'a LedgerMetadataFormat {
        <LedgerMetadataFormat as ::protobuf::Message>::default_instance()
    }
}

impl LedgerMetadataFormat {
    pub fn new() -> LedgerMetadataFormat {
        ::std::default::Default::default()
    }

    // required int32 quorumSize = 1;


    pub fn get_quorumSize(&self) -> i32 {
        self.quorumSize.unwrap_or(0)
    }
    pub fn clear_quorumSize(&mut self) {
        self.quorumSize = ::std::option::Option::None;
    }

    pub fn has_quorumSize(&self) -> bool {
        self.quorumSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quorumSize(&mut self, v: i32) {
        self.quorumSize = ::std::option::Option::Some(v);
    }

    // required int32 ensembleSize = 2;


    pub fn get_ensembleSize(&self) -> i32 {
        self.ensembleSize.unwrap_or(0)
    }
    pub fn clear_ensembleSize(&mut self) {
        self.ensembleSize = ::std::option::Option::None;
    }

    pub fn has_ensembleSize(&self) -> bool {
        self.ensembleSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ensembleSize(&mut self, v: i32) {
        self.ensembleSize = ::std::option::Option::Some(v);
    }

    // required int64 length = 3;


    pub fn get_length(&self) -> i64 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i64) {
        self.length = ::std::option::Option::Some(v);
    }

    // optional int64 lastEntryId = 4;


    pub fn get_lastEntryId(&self) -> i64 {
        self.lastEntryId.unwrap_or(0)
    }
    pub fn clear_lastEntryId(&mut self) {
        self.lastEntryId = ::std::option::Option::None;
    }

    pub fn has_lastEntryId(&self) -> bool {
        self.lastEntryId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastEntryId(&mut self, v: i64) {
        self.lastEntryId = ::std::option::Option::Some(v);
    }

    // required .bk.proto.LedgerMetadataFormat.State state = 5;


    pub fn get_state(&self) -> LedgerMetadataFormat_State {
        self.state.unwrap_or(LedgerMetadataFormat_State::OPEN)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: LedgerMetadataFormat_State) {
        self.state = ::std::option::Option::Some(v);
    }

    // repeated .bk.proto.LedgerMetadataFormat.Segment segment = 6;


    pub fn get_segment(&self) -> &[LedgerMetadataFormat_Segment] {
        &self.segment
    }
    pub fn clear_segment(&mut self) {
        self.segment.clear();
    }

    // Param is passed by value, moved
    pub fn set_segment(&mut self, v: ::protobuf::RepeatedField<LedgerMetadataFormat_Segment>) {
        self.segment = v;
    }

    // Mutable pointer to the field.
    pub fn mut_segment(&mut self) -> &mut ::protobuf::RepeatedField<LedgerMetadataFormat_Segment> {
        &mut self.segment
    }

    // Take field
    pub fn take_segment(&mut self) -> ::protobuf::RepeatedField<LedgerMetadataFormat_Segment> {
        ::std::mem::replace(&mut self.segment, ::protobuf::RepeatedField::new())
    }

    // optional .bk.proto.LedgerMetadataFormat.DigestType digestType = 7;


    pub fn get_digestType(&self) -> LedgerMetadataFormat_DigestType {
        self.digestType.unwrap_or(LedgerMetadataFormat_DigestType::CRC32)
    }
    pub fn clear_digestType(&mut self) {
        self.digestType = ::std::option::Option::None;
    }

    pub fn has_digestType(&self) -> bool {
        self.digestType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_digestType(&mut self, v: LedgerMetadataFormat_DigestType) {
        self.digestType = ::std::option::Option::Some(v);
    }

    // optional bytes password = 8;


    pub fn get_password(&self) -> &[u8] {
        match self.password.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.password.is_none() {
            self.password.set_default();
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::vec::Vec<u8> {
        self.password.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 ackQuorumSize = 9;


    pub fn get_ackQuorumSize(&self) -> i32 {
        self.ackQuorumSize.unwrap_or(0)
    }
    pub fn clear_ackQuorumSize(&mut self) {
        self.ackQuorumSize = ::std::option::Option::None;
    }

    pub fn has_ackQuorumSize(&self) -> bool {
        self.ackQuorumSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ackQuorumSize(&mut self, v: i32) {
        self.ackQuorumSize = ::std::option::Option::Some(v);
    }

    // optional int64 ctime = 10;


    pub fn get_ctime(&self) -> i64 {
        self.ctime.unwrap_or(0)
    }
    pub fn clear_ctime(&mut self) {
        self.ctime = ::std::option::Option::None;
    }

    pub fn has_ctime(&self) -> bool {
        self.ctime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctime(&mut self, v: i64) {
        self.ctime = ::std::option::Option::Some(v);
    }

    // repeated .bk.proto.LedgerMetadataFormat.cMetadataMapEntry customMetadata = 11;


    pub fn get_customMetadata(&self) -> &[LedgerMetadataFormat_cMetadataMapEntry] {
        &self.customMetadata
    }
    pub fn clear_customMetadata(&mut self) {
        self.customMetadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_customMetadata(&mut self, v: ::protobuf::RepeatedField<LedgerMetadataFormat_cMetadataMapEntry>) {
        self.customMetadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_customMetadata(&mut self) -> &mut ::protobuf::RepeatedField<LedgerMetadataFormat_cMetadataMapEntry> {
        &mut self.customMetadata
    }

    // Take field
    pub fn take_customMetadata(&mut self) -> ::protobuf::RepeatedField<LedgerMetadataFormat_cMetadataMapEntry> {
        ::std::mem::replace(&mut self.customMetadata, ::protobuf::RepeatedField::new())
    }

    // optional int64 cToken = 12;


    pub fn get_cToken(&self) -> i64 {
        self.cToken.unwrap_or(0)
    }
    pub fn clear_cToken(&mut self) {
        self.cToken = ::std::option::Option::None;
    }

    pub fn has_cToken(&self) -> bool {
        self.cToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cToken(&mut self, v: i64) {
        self.cToken = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for LedgerMetadataFormat {
    fn is_initialized(&self) -> bool {
        if self.quorumSize.is_none() {
            return false;
        }
        if self.ensembleSize.is_none() {
            return false;
        }
        if self.length.is_none() {
            return false;
        }
        if self.state.is_none() {
            return false;
        }
        for v in &self.segment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.customMetadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.quorumSize = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ensembleSize = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lastEntryId = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.segment)?;
                },
                7 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.digestType, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.password)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ackQuorumSize = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ctime = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.customMetadata)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cToken = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quorumSize {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ensembleSize {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastEntryId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        for value in &self.segment {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.digestType {
            my_size += ::protobuf::rt::enum_size(7, v);
        }
        if let Some(ref v) = self.password.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.ackQuorumSize {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ctime {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.customMetadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.cToken {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quorumSize {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ensembleSize {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.length {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.lastEntryId {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.segment {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.digestType {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.password.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(v) = self.ackQuorumSize {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.ctime {
            os.write_int64(10, v)?;
        }
        for v in &self.customMetadata {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.cToken {
            os.write_int64(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LedgerMetadataFormat {
        LedgerMetadataFormat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "quorumSize",
                |m: &LedgerMetadataFormat| { &m.quorumSize },
                |m: &mut LedgerMetadataFormat| { &mut m.quorumSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ensembleSize",
                |m: &LedgerMetadataFormat| { &m.ensembleSize },
                |m: &mut LedgerMetadataFormat| { &mut m.ensembleSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "length",
                |m: &LedgerMetadataFormat| { &m.length },
                |m: &mut LedgerMetadataFormat| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lastEntryId",
                |m: &LedgerMetadataFormat| { &m.lastEntryId },
                |m: &mut LedgerMetadataFormat| { &mut m.lastEntryId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LedgerMetadataFormat_State>>(
                "state",
                |m: &LedgerMetadataFormat| { &m.state },
                |m: &mut LedgerMetadataFormat| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LedgerMetadataFormat_Segment>>(
                "segment",
                |m: &LedgerMetadataFormat| { &m.segment },
                |m: &mut LedgerMetadataFormat| { &mut m.segment },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LedgerMetadataFormat_DigestType>>(
                "digestType",
                |m: &LedgerMetadataFormat| { &m.digestType },
                |m: &mut LedgerMetadataFormat| { &mut m.digestType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "password",
                |m: &LedgerMetadataFormat| { &m.password },
                |m: &mut LedgerMetadataFormat| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ackQuorumSize",
                |m: &LedgerMetadataFormat| { &m.ackQuorumSize },
                |m: &mut LedgerMetadataFormat| { &mut m.ackQuorumSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ctime",
                |m: &LedgerMetadataFormat| { &m.ctime },
                |m: &mut LedgerMetadataFormat| { &mut m.ctime },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LedgerMetadataFormat_cMetadataMapEntry>>(
                "customMetadata",
                |m: &LedgerMetadataFormat| { &m.customMetadata },
                |m: &mut LedgerMetadataFormat| { &mut m.customMetadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cToken",
                |m: &LedgerMetadataFormat| { &m.cToken },
                |m: &mut LedgerMetadataFormat| { &mut m.cToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LedgerMetadataFormat>(
                "LedgerMetadataFormat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LedgerMetadataFormat {
        static instance: ::protobuf::rt::LazyV2<LedgerMetadataFormat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LedgerMetadataFormat::new)
    }
}

impl ::protobuf::Clear for LedgerMetadataFormat {
    fn clear(&mut self) {
        self.quorumSize = ::std::option::Option::None;
        self.ensembleSize = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.lastEntryId = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.segment.clear();
        self.digestType = ::std::option::Option::None;
        self.password.clear();
        self.ackQuorumSize = ::std::option::Option::None;
        self.ctime = ::std::option::Option::None;
        self.customMetadata.clear();
        self.cToken = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LedgerMetadataFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LedgerMetadataFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LedgerMetadataFormat_Segment {
    // message fields
    pub ensembleMember: ::protobuf::RepeatedField<::std::string::String>,
    firstEntryId: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LedgerMetadataFormat_Segment {
    fn default() -> &'a LedgerMetadataFormat_Segment {
        <LedgerMetadataFormat_Segment as ::protobuf::Message>::default_instance()
    }
}

impl LedgerMetadataFormat_Segment {
    pub fn new() -> LedgerMetadataFormat_Segment {
        ::std::default::Default::default()
    }

    // repeated string ensembleMember = 1;


    pub fn get_ensembleMember(&self) -> &[::std::string::String] {
        &self.ensembleMember
    }
    pub fn clear_ensembleMember(&mut self) {
        self.ensembleMember.clear();
    }

    // Param is passed by value, moved
    pub fn set_ensembleMember(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ensembleMember = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ensembleMember(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ensembleMember
    }

    // Take field
    pub fn take_ensembleMember(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ensembleMember, ::protobuf::RepeatedField::new())
    }

    // required int64 firstEntryId = 2;


    pub fn get_firstEntryId(&self) -> i64 {
        self.firstEntryId.unwrap_or(0)
    }
    pub fn clear_firstEntryId(&mut self) {
        self.firstEntryId = ::std::option::Option::None;
    }

    pub fn has_firstEntryId(&self) -> bool {
        self.firstEntryId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstEntryId(&mut self, v: i64) {
        self.firstEntryId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for LedgerMetadataFormat_Segment {
    fn is_initialized(&self) -> bool {
        if self.firstEntryId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ensembleMember)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.firstEntryId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ensembleMember {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.firstEntryId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ensembleMember {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.firstEntryId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LedgerMetadataFormat_Segment {
        LedgerMetadataFormat_Segment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ensembleMember",
                |m: &LedgerMetadataFormat_Segment| { &m.ensembleMember },
                |m: &mut LedgerMetadataFormat_Segment| { &mut m.ensembleMember },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "firstEntryId",
                |m: &LedgerMetadataFormat_Segment| { &m.firstEntryId },
                |m: &mut LedgerMetadataFormat_Segment| { &mut m.firstEntryId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LedgerMetadataFormat_Segment>(
                "LedgerMetadataFormat.Segment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LedgerMetadataFormat_Segment {
        static instance: ::protobuf::rt::LazyV2<LedgerMetadataFormat_Segment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LedgerMetadataFormat_Segment::new)
    }
}

impl ::protobuf::Clear for LedgerMetadataFormat_Segment {
    fn clear(&mut self) {
        self.ensembleMember.clear();
        self.firstEntryId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LedgerMetadataFormat_Segment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LedgerMetadataFormat_Segment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LedgerMetadataFormat_cMetadataMapEntry {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LedgerMetadataFormat_cMetadataMapEntry {
    fn default() -> &'a LedgerMetadataFormat_cMetadataMapEntry {
        <LedgerMetadataFormat_cMetadataMapEntry as ::protobuf::Message>::default_instance()
    }
}

impl LedgerMetadataFormat_cMetadataMapEntry {
    pub fn new() -> LedgerMetadataFormat_cMetadataMapEntry {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        match self.value.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        self.value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for LedgerMetadataFormat_cMetadataMapEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LedgerMetadataFormat_cMetadataMapEntry {
        LedgerMetadataFormat_cMetadataMapEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &LedgerMetadataFormat_cMetadataMapEntry| { &m.key },
                |m: &mut LedgerMetadataFormat_cMetadataMapEntry| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &LedgerMetadataFormat_cMetadataMapEntry| { &m.value },
                |m: &mut LedgerMetadataFormat_cMetadataMapEntry| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LedgerMetadataFormat_cMetadataMapEntry>(
                "LedgerMetadataFormat.cMetadataMapEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LedgerMetadataFormat_cMetadataMapEntry {
        static instance: ::protobuf::rt::LazyV2<LedgerMetadataFormat_cMetadataMapEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LedgerMetadataFormat_cMetadataMapEntry::new)
    }
}

impl ::protobuf::Clear for LedgerMetadataFormat_cMetadataMapEntry {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LedgerMetadataFormat_cMetadataMapEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LedgerMetadataFormat_cMetadataMapEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LedgerMetadataFormat_State {
    OPEN = 1,
    IN_RECOVERY = 2,
    CLOSED = 3,
}

impl ::protobuf::ProtobufEnum for LedgerMetadataFormat_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LedgerMetadataFormat_State> {
        match value {
            1 => ::std::option::Option::Some(LedgerMetadataFormat_State::OPEN),
            2 => ::std::option::Option::Some(LedgerMetadataFormat_State::IN_RECOVERY),
            3 => ::std::option::Option::Some(LedgerMetadataFormat_State::CLOSED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LedgerMetadataFormat_State] = &[
            LedgerMetadataFormat_State::OPEN,
            LedgerMetadataFormat_State::IN_RECOVERY,
            LedgerMetadataFormat_State::CLOSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LedgerMetadataFormat_State>("LedgerMetadataFormat.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LedgerMetadataFormat_State {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for LedgerMetadataFormat_State {
    fn default() -> Self {
        LedgerMetadataFormat_State::OPEN
    }
}

impl ::protobuf::reflect::ProtobufValue for LedgerMetadataFormat_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LedgerMetadataFormat_DigestType {
    CRC32 = 1,
    HMAC = 2,
    CRC32C = 3,
    DUMMY = 4,
}

impl ::protobuf::ProtobufEnum for LedgerMetadataFormat_DigestType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LedgerMetadataFormat_DigestType> {
        match value {
            1 => ::std::option::Option::Some(LedgerMetadataFormat_DigestType::CRC32),
            2 => ::std::option::Option::Some(LedgerMetadataFormat_DigestType::HMAC),
            3 => ::std::option::Option::Some(LedgerMetadataFormat_DigestType::CRC32C),
            4 => ::std::option::Option::Some(LedgerMetadataFormat_DigestType::DUMMY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LedgerMetadataFormat_DigestType] = &[
            LedgerMetadataFormat_DigestType::CRC32,
            LedgerMetadataFormat_DigestType::HMAC,
            LedgerMetadataFormat_DigestType::CRC32C,
            LedgerMetadataFormat_DigestType::DUMMY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LedgerMetadataFormat_DigestType>("LedgerMetadataFormat.DigestType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LedgerMetadataFormat_DigestType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for LedgerMetadataFormat_DigestType {
    fn default() -> Self {
        LedgerMetadataFormat_DigestType::CRC32
    }
}

impl ::protobuf::reflect::ProtobufValue for LedgerMetadataFormat_DigestType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LedgerRereplicationLayoutFormat {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    version: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LedgerRereplicationLayoutFormat {
    fn default() -> &'a LedgerRereplicationLayoutFormat {
        <LedgerRereplicationLayoutFormat as ::protobuf::Message>::default_instance()
    }
}

impl LedgerRereplicationLayoutFormat {
    pub fn new() -> LedgerRereplicationLayoutFormat {
        ::std::default::Default::default()
    }

    // required string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 version = 2;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for LedgerRereplicationLayoutFormat {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.version {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LedgerRereplicationLayoutFormat {
        LedgerRereplicationLayoutFormat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &LedgerRereplicationLayoutFormat| { &m.field_type },
                |m: &mut LedgerRereplicationLayoutFormat| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &LedgerRereplicationLayoutFormat| { &m.version },
                |m: &mut LedgerRereplicationLayoutFormat| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LedgerRereplicationLayoutFormat>(
                "LedgerRereplicationLayoutFormat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LedgerRereplicationLayoutFormat {
        static instance: ::protobuf::rt::LazyV2<LedgerRereplicationLayoutFormat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LedgerRereplicationLayoutFormat::new)
    }
}

impl ::protobuf::Clear for LedgerRereplicationLayoutFormat {
    fn clear(&mut self) {
        self.field_type.clear();
        self.version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LedgerRereplicationLayoutFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LedgerRereplicationLayoutFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnderreplicatedLedgerFormat {
    // message fields
    pub replica: ::protobuf::RepeatedField<::std::string::String>,
    ctime: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnderreplicatedLedgerFormat {
    fn default() -> &'a UnderreplicatedLedgerFormat {
        <UnderreplicatedLedgerFormat as ::protobuf::Message>::default_instance()
    }
}

impl UnderreplicatedLedgerFormat {
    pub fn new() -> UnderreplicatedLedgerFormat {
        ::std::default::Default::default()
    }

    // repeated string replica = 1;


    pub fn get_replica(&self) -> &[::std::string::String] {
        &self.replica
    }
    pub fn clear_replica(&mut self) {
        self.replica.clear();
    }

    // Param is passed by value, moved
    pub fn set_replica(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.replica = v;
    }

    // Mutable pointer to the field.
    pub fn mut_replica(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.replica
    }

    // Take field
    pub fn take_replica(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.replica, ::protobuf::RepeatedField::new())
    }

    // optional int64 ctime = 2;


    pub fn get_ctime(&self) -> i64 {
        self.ctime.unwrap_or(0)
    }
    pub fn clear_ctime(&mut self) {
        self.ctime = ::std::option::Option::None;
    }

    pub fn has_ctime(&self) -> bool {
        self.ctime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctime(&mut self, v: i64) {
        self.ctime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UnderreplicatedLedgerFormat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.replica)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ctime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.replica {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.ctime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.replica {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.ctime {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnderreplicatedLedgerFormat {
        UnderreplicatedLedgerFormat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "replica",
                |m: &UnderreplicatedLedgerFormat| { &m.replica },
                |m: &mut UnderreplicatedLedgerFormat| { &mut m.replica },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ctime",
                |m: &UnderreplicatedLedgerFormat| { &m.ctime },
                |m: &mut UnderreplicatedLedgerFormat| { &mut m.ctime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnderreplicatedLedgerFormat>(
                "UnderreplicatedLedgerFormat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnderreplicatedLedgerFormat {
        static instance: ::protobuf::rt::LazyV2<UnderreplicatedLedgerFormat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnderreplicatedLedgerFormat::new)
    }
}

impl ::protobuf::Clear for UnderreplicatedLedgerFormat {
    fn clear(&mut self) {
        self.replica.clear();
        self.ctime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnderreplicatedLedgerFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnderreplicatedLedgerFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CookieFormat {
    // message fields
    bookieHost: ::protobuf::SingularField<::std::string::String>,
    journalDir: ::protobuf::SingularField<::std::string::String>,
    ledgerDirs: ::protobuf::SingularField<::std::string::String>,
    instanceId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CookieFormat {
    fn default() -> &'a CookieFormat {
        <CookieFormat as ::protobuf::Message>::default_instance()
    }
}

impl CookieFormat {
    pub fn new() -> CookieFormat {
        ::std::default::Default::default()
    }

    // required string bookieHost = 1;


    pub fn get_bookieHost(&self) -> &str {
        match self.bookieHost.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bookieHost(&mut self) {
        self.bookieHost.clear();
    }

    pub fn has_bookieHost(&self) -> bool {
        self.bookieHost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bookieHost(&mut self, v: ::std::string::String) {
        self.bookieHost = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bookieHost(&mut self) -> &mut ::std::string::String {
        if self.bookieHost.is_none() {
            self.bookieHost.set_default();
        }
        self.bookieHost.as_mut().unwrap()
    }

    // Take field
    pub fn take_bookieHost(&mut self) -> ::std::string::String {
        self.bookieHost.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string journalDir = 2;


    pub fn get_journalDir(&self) -> &str {
        match self.journalDir.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_journalDir(&mut self) {
        self.journalDir.clear();
    }

    pub fn has_journalDir(&self) -> bool {
        self.journalDir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_journalDir(&mut self, v: ::std::string::String) {
        self.journalDir = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_journalDir(&mut self) -> &mut ::std::string::String {
        if self.journalDir.is_none() {
            self.journalDir.set_default();
        }
        self.journalDir.as_mut().unwrap()
    }

    // Take field
    pub fn take_journalDir(&mut self) -> ::std::string::String {
        self.journalDir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string ledgerDirs = 3;


    pub fn get_ledgerDirs(&self) -> &str {
        match self.ledgerDirs.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ledgerDirs(&mut self) {
        self.ledgerDirs.clear();
    }

    pub fn has_ledgerDirs(&self) -> bool {
        self.ledgerDirs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerDirs(&mut self, v: ::std::string::String) {
        self.ledgerDirs = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ledgerDirs(&mut self) -> &mut ::std::string::String {
        if self.ledgerDirs.is_none() {
            self.ledgerDirs.set_default();
        }
        self.ledgerDirs.as_mut().unwrap()
    }

    // Take field
    pub fn take_ledgerDirs(&mut self) -> ::std::string::String {
        self.ledgerDirs.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string instanceId = 4;


    pub fn get_instanceId(&self) -> &str {
        match self.instanceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_instanceId(&mut self) {
        self.instanceId.clear();
    }

    pub fn has_instanceId(&self) -> bool {
        self.instanceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instanceId(&mut self, v: ::std::string::String) {
        self.instanceId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instanceId(&mut self) -> &mut ::std::string::String {
        if self.instanceId.is_none() {
            self.instanceId.set_default();
        }
        self.instanceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_instanceId(&mut self) -> ::std::string::String {
        self.instanceId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CookieFormat {
    fn is_initialized(&self) -> bool {
        if self.bookieHost.is_none() {
            return false;
        }
        if self.journalDir.is_none() {
            return false;
        }
        if self.ledgerDirs.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bookieHost)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.journalDir)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ledgerDirs)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instanceId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bookieHost.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.journalDir.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.ledgerDirs.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.instanceId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bookieHost.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.journalDir.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.ledgerDirs.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.instanceId.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CookieFormat {
        CookieFormat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bookieHost",
                |m: &CookieFormat| { &m.bookieHost },
                |m: &mut CookieFormat| { &mut m.bookieHost },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "journalDir",
                |m: &CookieFormat| { &m.journalDir },
                |m: &mut CookieFormat| { &mut m.journalDir },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ledgerDirs",
                |m: &CookieFormat| { &m.ledgerDirs },
                |m: &mut CookieFormat| { &mut m.ledgerDirs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instanceId",
                |m: &CookieFormat| { &m.instanceId },
                |m: &mut CookieFormat| { &mut m.instanceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CookieFormat>(
                "CookieFormat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CookieFormat {
        static instance: ::protobuf::rt::LazyV2<CookieFormat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CookieFormat::new)
    }
}

impl ::protobuf::Clear for CookieFormat {
    fn clear(&mut self) {
        self.bookieHost.clear();
        self.journalDir.clear();
        self.ledgerDirs.clear();
        self.instanceId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CookieFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CookieFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LockDataFormat {
    // message fields
    bookieId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LockDataFormat {
    fn default() -> &'a LockDataFormat {
        <LockDataFormat as ::protobuf::Message>::default_instance()
    }
}

impl LockDataFormat {
    pub fn new() -> LockDataFormat {
        ::std::default::Default::default()
    }

    // optional string bookieId = 1;


    pub fn get_bookieId(&self) -> &str {
        match self.bookieId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bookieId(&mut self) {
        self.bookieId.clear();
    }

    pub fn has_bookieId(&self) -> bool {
        self.bookieId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bookieId(&mut self, v: ::std::string::String) {
        self.bookieId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bookieId(&mut self) -> &mut ::std::string::String {
        if self.bookieId.is_none() {
            self.bookieId.set_default();
        }
        self.bookieId.as_mut().unwrap()
    }

    // Take field
    pub fn take_bookieId(&mut self) -> ::std::string::String {
        self.bookieId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for LockDataFormat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bookieId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bookieId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bookieId.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LockDataFormat {
        LockDataFormat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bookieId",
                |m: &LockDataFormat| { &m.bookieId },
                |m: &mut LockDataFormat| { &mut m.bookieId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LockDataFormat>(
                "LockDataFormat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LockDataFormat {
        static instance: ::protobuf::rt::LazyV2<LockDataFormat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LockDataFormat::new)
    }
}

impl ::protobuf::Clear for LockDataFormat {
    fn clear(&mut self) {
        self.bookieId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LockDataFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockDataFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuditorVoteFormat {
    // message fields
    bookieId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuditorVoteFormat {
    fn default() -> &'a AuditorVoteFormat {
        <AuditorVoteFormat as ::protobuf::Message>::default_instance()
    }
}

impl AuditorVoteFormat {
    pub fn new() -> AuditorVoteFormat {
        ::std::default::Default::default()
    }

    // optional string bookieId = 1;


    pub fn get_bookieId(&self) -> &str {
        match self.bookieId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bookieId(&mut self) {
        self.bookieId.clear();
    }

    pub fn has_bookieId(&self) -> bool {
        self.bookieId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bookieId(&mut self, v: ::std::string::String) {
        self.bookieId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bookieId(&mut self) -> &mut ::std::string::String {
        if self.bookieId.is_none() {
            self.bookieId.set_default();
        }
        self.bookieId.as_mut().unwrap()
    }

    // Take field
    pub fn take_bookieId(&mut self) -> ::std::string::String {
        self.bookieId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuditorVoteFormat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bookieId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bookieId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bookieId.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuditorVoteFormat {
        AuditorVoteFormat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bookieId",
                |m: &AuditorVoteFormat| { &m.bookieId },
                |m: &mut AuditorVoteFormat| { &mut m.bookieId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuditorVoteFormat>(
                "AuditorVoteFormat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuditorVoteFormat {
        static instance: ::protobuf::rt::LazyV2<AuditorVoteFormat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuditorVoteFormat::new)
    }
}

impl ::protobuf::Clear for AuditorVoteFormat {
    fn clear(&mut self) {
        self.bookieId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuditorVoteFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditorVoteFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckAllLedgersFormat {
    // message fields
    checkAllLedgersCTime: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckAllLedgersFormat {
    fn default() -> &'a CheckAllLedgersFormat {
        <CheckAllLedgersFormat as ::protobuf::Message>::default_instance()
    }
}

impl CheckAllLedgersFormat {
    pub fn new() -> CheckAllLedgersFormat {
        ::std::default::Default::default()
    }

    // optional int64 checkAllLedgersCTime = 1;


    pub fn get_checkAllLedgersCTime(&self) -> i64 {
        self.checkAllLedgersCTime.unwrap_or(0)
    }
    pub fn clear_checkAllLedgersCTime(&mut self) {
        self.checkAllLedgersCTime = ::std::option::Option::None;
    }

    pub fn has_checkAllLedgersCTime(&self) -> bool {
        self.checkAllLedgersCTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkAllLedgersCTime(&mut self, v: i64) {
        self.checkAllLedgersCTime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CheckAllLedgersFormat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.checkAllLedgersCTime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.checkAllLedgersCTime {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.checkAllLedgersCTime {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckAllLedgersFormat {
        CheckAllLedgersFormat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "checkAllLedgersCTime",
                |m: &CheckAllLedgersFormat| { &m.checkAllLedgersCTime },
                |m: &mut CheckAllLedgersFormat| { &mut m.checkAllLedgersCTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CheckAllLedgersFormat>(
                "CheckAllLedgersFormat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckAllLedgersFormat {
        static instance: ::protobuf::rt::LazyV2<CheckAllLedgersFormat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckAllLedgersFormat::new)
    }
}

impl ::protobuf::Clear for CheckAllLedgersFormat {
    fn clear(&mut self) {
        self.checkAllLedgersCTime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckAllLedgersFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckAllLedgersFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlacementPolicyCheckFormat {
    // message fields
    placementPolicyCheckCTime: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlacementPolicyCheckFormat {
    fn default() -> &'a PlacementPolicyCheckFormat {
        <PlacementPolicyCheckFormat as ::protobuf::Message>::default_instance()
    }
}

impl PlacementPolicyCheckFormat {
    pub fn new() -> PlacementPolicyCheckFormat {
        ::std::default::Default::default()
    }

    // optional int64 placementPolicyCheckCTime = 1;


    pub fn get_placementPolicyCheckCTime(&self) -> i64 {
        self.placementPolicyCheckCTime.unwrap_or(0)
    }
    pub fn clear_placementPolicyCheckCTime(&mut self) {
        self.placementPolicyCheckCTime = ::std::option::Option::None;
    }

    pub fn has_placementPolicyCheckCTime(&self) -> bool {
        self.placementPolicyCheckCTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_placementPolicyCheckCTime(&mut self, v: i64) {
        self.placementPolicyCheckCTime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PlacementPolicyCheckFormat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.placementPolicyCheckCTime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.placementPolicyCheckCTime {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.placementPolicyCheckCTime {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlacementPolicyCheckFormat {
        PlacementPolicyCheckFormat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "placementPolicyCheckCTime",
                |m: &PlacementPolicyCheckFormat| { &m.placementPolicyCheckCTime },
                |m: &mut PlacementPolicyCheckFormat| { &mut m.placementPolicyCheckCTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlacementPolicyCheckFormat>(
                "PlacementPolicyCheckFormat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlacementPolicyCheckFormat {
        static instance: ::protobuf::rt::LazyV2<PlacementPolicyCheckFormat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlacementPolicyCheckFormat::new)
    }
}

impl ::protobuf::Clear for PlacementPolicyCheckFormat {
    fn clear(&mut self) {
        self.placementPolicyCheckCTime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlacementPolicyCheckFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlacementPolicyCheckFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplicasCheckFormat {
    // message fields
    replicasCheckCTime: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplicasCheckFormat {
    fn default() -> &'a ReplicasCheckFormat {
        <ReplicasCheckFormat as ::protobuf::Message>::default_instance()
    }
}

impl ReplicasCheckFormat {
    pub fn new() -> ReplicasCheckFormat {
        ::std::default::Default::default()
    }

    // optional int64 replicasCheckCTime = 1;


    pub fn get_replicasCheckCTime(&self) -> i64 {
        self.replicasCheckCTime.unwrap_or(0)
    }
    pub fn clear_replicasCheckCTime(&mut self) {
        self.replicasCheckCTime = ::std::option::Option::None;
    }

    pub fn has_replicasCheckCTime(&self) -> bool {
        self.replicasCheckCTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicasCheckCTime(&mut self, v: i64) {
        self.replicasCheckCTime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ReplicasCheckFormat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replicasCheckCTime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.replicasCheckCTime {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.replicasCheckCTime {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplicasCheckFormat {
        ReplicasCheckFormat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "replicasCheckCTime",
                |m: &ReplicasCheckFormat| { &m.replicasCheckCTime },
                |m: &mut ReplicasCheckFormat| { &mut m.replicasCheckCTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReplicasCheckFormat>(
                "ReplicasCheckFormat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReplicasCheckFormat {
        static instance: ::protobuf::rt::LazyV2<ReplicasCheckFormat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReplicasCheckFormat::new)
    }
}

impl ::protobuf::Clear for ReplicasCheckFormat {
    fn clear(&mut self) {
        self.replicasCheckCTime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicasCheckFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicasCheckFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BookieServiceInfoFormat {
    // message fields
    pub endpoints: ::protobuf::RepeatedField<BookieServiceInfoFormat_Endpoint>,
    pub properties: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BookieServiceInfoFormat {
    fn default() -> &'a BookieServiceInfoFormat {
        <BookieServiceInfoFormat as ::protobuf::Message>::default_instance()
    }
}

impl BookieServiceInfoFormat {
    pub fn new() -> BookieServiceInfoFormat {
        ::std::default::Default::default()
    }

    // repeated .bk.proto.BookieServiceInfoFormat.Endpoint endpoints = 6;


    pub fn get_endpoints(&self) -> &[BookieServiceInfoFormat_Endpoint] {
        &self.endpoints
    }
    pub fn clear_endpoints(&mut self) {
        self.endpoints.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::protobuf::RepeatedField<BookieServiceInfoFormat_Endpoint>) {
        self.endpoints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpoints(&mut self) -> &mut ::protobuf::RepeatedField<BookieServiceInfoFormat_Endpoint> {
        &mut self.endpoints
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::protobuf::RepeatedField<BookieServiceInfoFormat_Endpoint> {
        ::std::mem::replace(&mut self.endpoints, ::protobuf::RepeatedField::new())
    }

    // repeated .bk.proto.BookieServiceInfoFormat.properties_MapEntry properties = 7;


    pub fn get_properties(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.properties, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for BookieServiceInfoFormat {
    fn is_initialized(&self) -> bool {
        for v in &self.endpoints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.endpoints)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.endpoints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.properties);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.endpoints {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.properties, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BookieServiceInfoFormat {
        BookieServiceInfoFormat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BookieServiceInfoFormat_Endpoint>>(
                "endpoints",
                |m: &BookieServiceInfoFormat| { &m.endpoints },
                |m: &mut BookieServiceInfoFormat| { &mut m.endpoints },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "properties",
                |m: &BookieServiceInfoFormat| { &m.properties },
                |m: &mut BookieServiceInfoFormat| { &mut m.properties },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BookieServiceInfoFormat>(
                "BookieServiceInfoFormat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BookieServiceInfoFormat {
        static instance: ::protobuf::rt::LazyV2<BookieServiceInfoFormat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BookieServiceInfoFormat::new)
    }
}

impl ::protobuf::Clear for BookieServiceInfoFormat {
    fn clear(&mut self) {
        self.endpoints.clear();
        self.properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BookieServiceInfoFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookieServiceInfoFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BookieServiceInfoFormat_Endpoint {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<i32>,
    host: ::protobuf::SingularField<::std::string::String>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    pub auth: ::protobuf::RepeatedField<::std::string::String>,
    pub extensions: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BookieServiceInfoFormat_Endpoint {
    fn default() -> &'a BookieServiceInfoFormat_Endpoint {
        <BookieServiceInfoFormat_Endpoint as ::protobuf::Message>::default_instance()
    }
}

impl BookieServiceInfoFormat_Endpoint {
    pub fn new() -> BookieServiceInfoFormat_Endpoint {
        ::std::default::Default::default()
    }

    // required string id = 1;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 port = 2;


    pub fn get_port(&self) -> i32 {
        self.port.unwrap_or(0)
    }
    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    // required string host = 3;


    pub fn get_host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host.set_default();
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string protocol = 4;


    pub fn get_protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string auth = 5;


    pub fn get_auth(&self) -> &[::std::string::String] {
        &self.auth
    }
    pub fn clear_auth(&mut self) {
        self.auth.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.auth = v;
    }

    // Mutable pointer to the field.
    pub fn mut_auth(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.auth
    }

    // Take field
    pub fn take_auth(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.auth, ::protobuf::RepeatedField::new())
    }

    // repeated string extensions = 6;


    pub fn get_extensions(&self) -> &[::std::string::String] {
        &self.extensions
    }
    pub fn clear_extensions(&mut self) {
        self.extensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_extensions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.extensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extensions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.extensions
    }

    // Take field
    pub fn take_extensions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.extensions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BookieServiceInfoFormat_Endpoint {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.port.is_none() {
            return false;
        }
        if self.host.is_none() {
            return false;
        }
        if self.protocol.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.auth)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.extensions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.auth {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.extensions {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.host.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.auth {
            os.write_string(5, &v)?;
        };
        for v in &self.extensions {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BookieServiceInfoFormat_Endpoint {
        BookieServiceInfoFormat_Endpoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &BookieServiceInfoFormat_Endpoint| { &m.id },
                |m: &mut BookieServiceInfoFormat_Endpoint| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "port",
                |m: &BookieServiceInfoFormat_Endpoint| { &m.port },
                |m: &mut BookieServiceInfoFormat_Endpoint| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &BookieServiceInfoFormat_Endpoint| { &m.host },
                |m: &mut BookieServiceInfoFormat_Endpoint| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protocol",
                |m: &BookieServiceInfoFormat_Endpoint| { &m.protocol },
                |m: &mut BookieServiceInfoFormat_Endpoint| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "auth",
                |m: &BookieServiceInfoFormat_Endpoint| { &m.auth },
                |m: &mut BookieServiceInfoFormat_Endpoint| { &mut m.auth },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "extensions",
                |m: &BookieServiceInfoFormat_Endpoint| { &m.extensions },
                |m: &mut BookieServiceInfoFormat_Endpoint| { &mut m.extensions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BookieServiceInfoFormat_Endpoint>(
                "BookieServiceInfoFormat.Endpoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BookieServiceInfoFormat_Endpoint {
        static instance: ::protobuf::rt::LazyV2<BookieServiceInfoFormat_Endpoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BookieServiceInfoFormat_Endpoint::new)
    }
}

impl ::protobuf::Clear for BookieServiceInfoFormat_Endpoint {
    fn clear(&mut self) {
        self.id.clear();
        self.port = ::std::option::Option::None;
        self.host.clear();
        self.protocol.clear();
        self.auth.clear();
        self.extensions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BookieServiceInfoFormat_Endpoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookieServiceInfoFormat_Endpoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11DataFormats.proto\x12\x08bk.proto\"\xd5\x06\n\x14LedgerMetadataFor\
    mat\x12\x20\n\nquorumSize\x18\x01\x20\x02(\x05R\nquorumSizeB\0\x12$\n\
    \x0censembleSize\x18\x02\x20\x02(\x05R\x0censembleSizeB\0\x12\x18\n\x06l\
    ength\x18\x03\x20\x02(\x03R\x06lengthB\0\x12\"\n\x0blastEntryId\x18\x04\
    \x20\x01(\x03R\x0blastEntryIdB\0\x12B\n\x05state\x18\x05\x20\x02(\x0e2$.\
    bk.proto.LedgerMetadataFormat.State:\x04OPENR\x05stateB\0\x12B\n\x07segm\
    ent\x18\x06\x20\x03(\x0b2&.bk.proto.LedgerMetadataFormat.SegmentR\x07seg\
    mentB\0\x12K\n\ndigestType\x18\x07\x20\x01(\x0e2).bk.proto.LedgerMetadat\
    aFormat.DigestTypeR\ndigestTypeB\0\x12\x1c\n\x08password\x18\x08\x20\x01\
    (\x0cR\x08passwordB\0\x12&\n\rackQuorumSize\x18\t\x20\x01(\x05R\rackQuor\
    umSizeB\0\x12\x16\n\x05ctime\x18\n\x20\x01(\x03R\x05ctimeB\0\x12Z\n\x0ec\
    ustomMetadata\x18\x0b\x20\x03(\x0b20.bk.proto.LedgerMetadataFormat.cMeta\
    dataMapEntryR\x0ecustomMetadataB\0\x12\x18\n\x06cToken\x18\x0c\x20\x01(\
    \x03R\x06cTokenB\0\x1a[\n\x07Segment\x12(\n\x0eensembleMember\x18\x01\
    \x20\x03(\tR\x0eensembleMemberB\0\x12$\n\x0cfirstEntryId\x18\x02\x20\x02\
    (\x03R\x0cfirstEntryIdB\0:\0\x1aA\n\x11cMetadataMapEntry\x12\x12\n\x03ke\
    y\x18\x01\x20\x01(\tR\x03keyB\0\x12\x16\n\x05value\x18\x02\x20\x01(\x0cR\
    \x05valueB\0:\0\"0\n\x05State\x12\x08\n\x04OPEN\x10\x01\x12\x0f\n\x0bIN_\
    RECOVERY\x10\x02\x12\n\n\x06CLOSED\x10\x03\x1a\0\":\n\nDigestType\x12\t\
    \n\x05CRC32\x10\x01\x12\x08\n\x04HMAC\x10\x02\x12\n\n\x06CRC32C\x10\x03\
    \x12\t\n\x05DUMMY\x10\x04\x1a\0:\0\"U\n\x1fLedgerRereplicationLayoutForm\
    at\x12\x14\n\x04type\x18\x01\x20\x02(\tR\x04typeB\0\x12\x1a\n\x07version\
    \x18\x02\x20\x02(\x05R\x07versionB\0:\0\"S\n\x1bUnderreplicatedLedgerFor\
    mat\x12\x1a\n\x07replica\x18\x01\x20\x03(\tR\x07replicaB\0\x12\x16\n\x05\
    ctime\x18\x02\x20\x01(\x03R\x05ctimeB\0:\0\"\x98\x01\n\x0cCookieFormat\
    \x12\x20\n\nbookieHost\x18\x01\x20\x02(\tR\nbookieHostB\0\x12\x20\n\njou\
    rnalDir\x18\x02\x20\x02(\tR\njournalDirB\0\x12\x20\n\nledgerDirs\x18\x03\
    \x20\x02(\tR\nledgerDirsB\0\x12\x20\n\ninstanceId\x18\x04\x20\x01(\tR\ni\
    nstanceIdB\0:\0\"0\n\x0eLockDataFormat\x12\x1c\n\x08bookieId\x18\x01\x20\
    \x01(\tR\x08bookieIdB\0:\0\"3\n\x11AuditorVoteFormat\x12\x1c\n\x08bookie\
    Id\x18\x01\x20\x01(\tR\x08bookieIdB\0:\0\"O\n\x15CheckAllLedgersFormat\
    \x124\n\x14checkAllLedgersCTime\x18\x01\x20\x01(\x03R\x14checkAllLedgers\
    CTimeB\0:\0\"^\n\x1aPlacementPolicyCheckFormat\x12>\n\x19placementPolicy\
    CheckCTime\x18\x01\x20\x01(\x03R\x19placementPolicyCheckCTimeB\0:\0\"I\n\
    \x13ReplicasCheckFormat\x120\n\x12replicasCheckCTime\x18\x01\x20\x01(\
    \x03R\x12replicasCheckCTimeB\0:\0\"\xa2\x03\n\x17BookieServiceInfoFormat\
    \x12J\n\tendpoints\x18\x06\x20\x03(\x0b2*.bk.proto.BookieServiceInfoForm\
    at.EndpointR\tendpointsB\0\x12W\n\nproperties\x18\x07\x20\x03(\x0b25.bk.\
    proto.BookieServiceInfoFormat.properties_MapEntryR\npropertiesB\0\x1a\
    \xa0\x01\n\x08Endpoint\x12\x10\n\x02id\x18\x01\x20\x02(\tR\x02idB\0\x12\
    \x14\n\x04port\x18\x02\x20\x02(\x05R\x04portB\0\x12\x14\n\x04host\x18\
    \x03\x20\x02(\tR\x04hostB\0\x12\x1c\n\x08protocol\x18\x04\x20\x02(\tR\
    \x08protocolB\0\x12\x14\n\x04auth\x18\x05\x20\x03(\tR\x04authB\0\x12\x20\
    \n\nextensions\x18\x06\x20\x03(\tR\nextensionsB\0:\0\x1a=\n\x13propertie\
    s_MapEntry\x12\x0e\n\x03key\x18\x01(\tR\x03key\x12\x12\n\x05value\x18\
    \x02(\tR\x05value:\x028\x01:\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
